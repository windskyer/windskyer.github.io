<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZWEI</title>
  
  <subtitle>Time flies.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.flftuu.com/"/>
  <updated>2020-08-20T11:53:24.586Z</updated>
  <id>https://www.flftuu.com/</id>
  
  <author>
    <name>zwei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nginx日志时间输出</title>
    <link href="https://www.flftuu.com/2020/04/26/nginx%E6%97%A5%E5%BF%97%E6%97%B6%E9%97%B4%E8%BE%93%E5%87%BA/"/>
    <id>https://www.flftuu.com/2020/04/26/nginx日志时间输出/</id>
    <published>2020-04-26T08:50:43.000Z</published>
    <updated>2020-08-20T11:53:24.586Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="nginx-日志打印响应时间-request-time-和-upstream-response-time"><a href="#nginx-日志打印响应时间-request-time-和-upstream-response-time" class="headerlink" title="nginx 日志打印响应时间 request_time 和 upstream_response_time"></a>nginx 日志打印响应时间 request_time 和 upstream_response_time</h2><h5 id="设置log-format，添加request-time，-upstream-response-time，位置随意"><a href="#设置log-format，添加request-time，-upstream-response-time，位置随意" class="headerlink" title="设置log_format，添加request_time，$upstream_response_time，位置随意"></a>设置log_format，添加request_time，$upstream_response_time，位置随意</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">log_format  main  <span class="string">'"$request_time" "$upstream_response_time" $remote_addr - $remote_user [$time_local] "$request" '</span></div><div class="line"></div><div class="line">                      <span class="string">'$status $body_bytes_sent "$http_referer" '</span></div><div class="line"></div><div class="line">                      <span class="string">'"$http_user_agent" "$http_x_forwarded_for"'</span>;</div></pre></td></tr></tbody></table></figure><a id="more"></a><h5 id="日志输出效果："><a href="#日志输出效果：" class="headerlink" title="日志输出效果："></a>日志输出效果：</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"0.015"</span> <span class="string">"0.015"</span> 10.1.2.3 - - [20/Mar/2017:04:05:49 +0800] <span class="string">"GET /myApp/servlet/TestServlet HTTP/1.1"</span> 200 52 <span class="string">"-"</span> <span class="string">"Mozilla/4.0 (compatible; MSIE 4.0; Windows NT)"</span> <span class="string">"-"</span></div></pre></td></tr></tbody></table></figure><hr><p>根据nginx的accesslog中$request_time进行程序优化时，发现有个接口，直接返回数据，平均的$request_time也比较大。原来$request_time包含了用户数据接收时间，而真正程序的响应时间应该用$upstream_response_time。</p><h2 id="下面介绍下2者的差别："><a href="#下面介绍下2者的差别：" class="headerlink" title="下面介绍下2者的差别："></a>下面介绍下2者的差别：</h2><p>1、request_time</p><p>官网描述：request processing time in seconds with a milliseconds resolution; time elapsed between the first bytes were read from the client and the log write after the last bytes were sent to the client 。</p><p>指的就是从接受用户请求的第一个字节到发送完响应数据的时间，即包括接收请求数据时间、程序响应时间、输出</p><p>响应数据时间。</p><p>2、upstream_response_time</p><p>官网描述：keeps times of responses obtained from upstream servers; times are kept in seconds with a milliseconds resolution. Several response times are separated by commas and colons like addresses in the $upstream_addr variable</p><p>是指从Nginx向后端建立连接开始到接受完数据然后关闭连接为止的时间。</p><p>从上面的描述可以看出，$request_time肯定比$upstream_response_time值大，特别是使用POST方式传递参数时，因为Nginx会把request body缓存住，接受完毕后才会把数据一起发给后端。所以如果用户网络较差，或者传递数据较大时，$request_time会比$upstream_response_time大很多。</p><p>所以如果使用nginx的accesslog查看php程序中哪些接口比较慢的话，记得在log_format中加入$upstream_response_time。</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;nginx-日志打印响应时间-request-time-和-upstream-response-time&quot;&gt;&lt;a href=&quot;#nginx-日志打印响应时间-request-time-和-upstream-response-time&quot; class=&quot;headerlink&quot; title=&quot;nginx 日志打印响应时间 request_time 和 upstream_response_time&quot;&gt;&lt;/a&gt;nginx 日志打印响应时间 request_time 和 upstream_response_time&lt;/h2&gt;&lt;h5 id=&quot;设置log-format，添加request-time，-upstream-response-time，位置随意&quot;&gt;&lt;a href=&quot;#设置log-format，添加request-time，-upstream-response-time，位置随意&quot; class=&quot;headerlink&quot; title=&quot;设置log_format，添加request_time，$upstream_response_time，位置随意&quot;&gt;&lt;/a&gt;设置log_format，添加request_time，$upstream_response_time，位置随意&lt;/h5&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;log_format  main  &lt;span class=&quot;string&quot;&gt;&#39;&quot;$request_time&quot; &quot;$upstream_response_time&quot; $remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                      &lt;span class=&quot;string&quot;&gt;&#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                      &lt;span class=&quot;string&quot;&gt;&#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;&lt;/span&gt;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Kubernetes" scheme="https://www.flftuu.com/categories/Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>k8s节点下线</title>
    <link href="https://www.flftuu.com/2020/04/20/k8s%E8%8A%82%E7%82%B9%E4%B8%8B%E7%BA%BF/"/>
    <id>https://www.flftuu.com/2020/04/20/k8s节点下线/</id>
    <published>2020-04-20T08:43:04.000Z</published>
    <updated>2020-08-20T08:52:05.016Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>下线一般有两种情况,一般是故障或者是迁移。故障节点下线只需要直接摘除下来就可以，因为会从新调度到新的节点。而正常节点迁移则需要先排干节点，即将所有pod在此节点上迁移出去其他节点。<br><a id="more"></a></p><h1 id="正常节点下线"><a href="#正常节点下线" class="headerlink" title="正常节点下线"></a>正常节点下线</h1><h2 id="查看节点"><a href="#查看节点" class="headerlink" title="查看节点"></a>查看节点</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubectl get node xxx</div></pre></td></tr></tbody></table></figure><h2 id="排干-排干时他们提示忽略了ds的pod"><a href="#排干-排干时他们提示忽略了ds的pod" class="headerlink" title="排干,排干时他们提示忽略了ds的pod"></a>排干,排干时他们提示忽略了ds的pod</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubectl drain hdss7-21.host.com --delete-local-data --force --ignore-daemonsets</div></pre></td></tr></tbody></table></figure><p><strong>注意: 在排干的过程中,此节点标记为不可以调度的状态</strong></p><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubectl delete node hdss7-21.host.com</div></pre></td></tr></tbody></table></figure><p>异常节点直接删除即可，修复后启动服务，节点将自动加入集群</p><h1 id="异常节点下线"><a href="#异常节点下线" class="headerlink" title="异常节点下线"></a>异常节点下线</h1><h2 id="删除节点-1"><a href="#删除节点-1" class="headerlink" title="删除节点"></a>删除节点</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubectl delete node hdss7-21.host.com</div></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下线一般有两种情况,一般是故障或者是迁移。故障节点下线只需要直接摘除下来就可以，因为会从新调度到新的节点。而正常节点迁移则需要先排干节点，即将所有pod在此节点上迁移出去其他节点。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Kubernetes" scheme="https://www.flftuu.com/categories/Kubernetes/"/>
    
    
      <category term="k8s" scheme="https://www.flftuu.com/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Golang sync.Mutex用法（互斥量用法）</title>
    <link href="https://www.flftuu.com/2020/04/18/Golang-sync-Mutex%E7%94%A8%E6%B3%95%EF%BC%88%E4%BA%92%E6%96%A5%E9%87%8F%E7%94%A8%E6%B3%95%EF%BC%89/"/>
    <id>https://www.flftuu.com/2020/04/18/Golang-sync-Mutex用法（互斥量用法）/</id>
    <published>2020-04-18T10:01:58.000Z</published>
    <updated>2020-06-10T10:14:47.913Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>golang 中的 sync 包实现了两种锁：</p><blockquote><ol><li>Mutex：互斥锁</li><li>RWMutex：读写锁，RWMutex 基于 Mutex 实现</li></ol></blockquote><a id="more"></a><h2 id="Mutex（互斥锁）"><a href="#Mutex（互斥锁）" class="headerlink" title="Mutex（互斥锁）"></a>Mutex（互斥锁）</h2><blockquote><ol><li>Mutex 为互斥锁，Lock() 加锁，Unlock() 解锁</li><li>在一个 goroutine 获得 Mutex 后，其他 goroutine 只能等到这个 goroutine 释放该 Mutex</li><li>使用 Lock() 加锁后，不能再继续对其加锁，直到利用 Unlock() 解锁后才能再加锁</li><li>在 Lock() 之前使用 Unlock() 会导致 panic 异常</li><li>已经锁定的 Mutex 并不与特定的 goroutine 相关联，这样可以利用一个 goroutine 对其加锁，再利用其他 goroutine 对其解锁</li><li>在同一个 goroutine 中的 Mutex 解锁之前再次进行加锁，会导致死锁</li><li>适用于读写不确定，并且只有一个读或者写的场景</li></ol></blockquote><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="加锁和解锁示例"><a href="#加锁和解锁示例" class="headerlink" title="加锁和解锁示例"></a>加锁和解锁示例</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"time"</span></div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"sync"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</div><div class="line">    <span class="keyword">var</span> mutex sync.Mutex</div><div class="line">    fmt.Println(<span class="string">"Lock the lock"</span>)</div><div class="line">    mutex.Lock()</div><div class="line">    fmt.Println(<span class="string">"The lock is locked"</span>)</div><div class="line">    channels := <span class="built_in">make</span>([]<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">4</span>)</div><div class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i < <span class="number">4</span>; i++ {</div><div class="line">        channels[i] = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</div><div class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</div><div class="line">            fmt.Println(<span class="string">"Not lock: "</span>, i)</div><div class="line">            mutex.Lock()</div><div class="line">            fmt.Println(<span class="string">"Locked: "</span>, i)</div><div class="line">            time.Sleep(time.Second)</div><div class="line">            fmt.Println(<span class="string">"Unlock the lock: "</span>, i)</div><div class="line">            mutex.Unlock()</div><div class="line">            c <- i</div><div class="line">        }(i, channels[i])</div><div class="line">    }</div><div class="line">    time.Sleep(time.Second)</div><div class="line">    fmt.Println(<span class="string">"Unlock the lock"</span>)</div><div class="line">    mutex.Unlock()</div><div class="line">    time.Sleep(time.Second)</div><div class="line"></div><div class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> channels {</div><div class="line">        <-c</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></tbody></table></figure><p>程序输出：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Lock the lock</div><div class="line">The lock is locked</div><div class="line">Not lock:  1</div><div class="line">Not lock:  2</div><div class="line">Not lock:  0</div><div class="line">Not lock:  3</div><div class="line">Unlock the lock</div><div class="line">Locked:  1</div><div class="line">Unlock the lock:  1</div><div class="line">Locked:  2</div><div class="line">Unlock the lock:  2</div><div class="line">Locked:  3</div><div class="line">Unlock the lock:  3</div><div class="line">Locked:  0</div><div class="line">Unlock the lock:  0</div></pre></td></tr></tbody></table></figure><h3 id="在解锁之前加锁会导致死锁"><a href="#在解锁之前加锁会导致死锁" class="headerlink" title="在解锁之前加锁会导致死锁"></a>在解锁之前加锁会导致死锁</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"sync"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</div><div class="line">    <span class="keyword">var</span> mutex sync.Mutex</div><div class="line">    mutex.Lock()</div><div class="line">    fmt.Println(<span class="string">"Locked"</span>)</div><div class="line">    mutex.Lock()</div><div class="line">}</div></pre></td></tr></tbody></table></figure><p>程序输出：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Locked</div><div class="line">fatal error: all goroutines are asleep - deadlock!</div></pre></td></tr></tbody></table></figure><p></p><h2 id="RWMutex（读写锁）"><a href="#RWMutex（读写锁）" class="headerlink" title="RWMutex（读写锁）"></a>RWMutex（读写锁）</h2><blockquote><ol><li>RWMutex 是单写多读锁，该锁可以加多个读锁或者一个写锁</li><li>读锁占用的情况下会阻止写，不会阻止读，多个 goroutine 可以同时获取读锁</li><li>写锁会阻止其他 goroutine（无论读和写）进来，整个锁由该 goroutine 独占</li><li>适用于读多写少的场景</li></ol></blockquote><h2 id="Lock-和-Unlock"><a href="#Lock-和-Unlock" class="headerlink" title="Lock() 和 Unlock()"></a>Lock() 和 Unlock()</h2><blockquote><ol><li>Lock() 加写锁，Unlock() 解写锁</li><li>如果在加写锁之前已经有其他的读锁和写锁，则 Lock() 会阻塞直到该锁可用，为确保锁可用，已经阻塞的 Lock() 调用会从获得的锁中排除新的读取器，即写锁权限高于读锁，有写锁时优先进行写锁定</li><li>在 Lock() 之前使用 Unlock() 会导致 panic 异常</li></ol></blockquote><h2 id="RLock-和-RUnlock"><a href="#RLock-和-RUnlock" class="headerlink" title="RLock() 和 RUnlock()"></a>RLock() 和 RUnlock()</h2><blockquote><ol><li>RLock() 加读锁，RUnlock() 解读锁</li><li>RLock() 加读锁时，如果存在写锁，则无法加读锁；当只有读锁或者没有锁时，可以加读锁，读锁可以加载多个</li><li>RUnlock() 解读锁，RUnlock() 撤销单词 RLock() 调用，对于其他同时存在的读锁则没有效果</li><li>在没有读锁的情况下调用 RUnlock() 会导致 panic 错误</li><li>RUnlock() 的个数不得多余 RLock()，否则会导致 panic 错误</li></ol></blockquote><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><h3 id="Lock-和-Unlock-1"><a href="#Lock-和-Unlock-1" class="headerlink" title="Lock() 和 Unlock()"></a>Lock() 和 Unlock()</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"sync"</span></div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</div><div class="line">    <span class="keyword">var</span> mutex *sync.RWMutex</div><div class="line">    mutex = <span class="built_in">new</span>(sync.RWMutex)</div><div class="line">    fmt.Println(<span class="string">"Lock the lock"</span>)</div><div class="line">    mutex.Lock()</div><div class="line">    fmt.Println(<span class="string">"The lock is locked"</span>)</div><div class="line"></div><div class="line">    channels := <span class="built_in">make</span>([]<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">4</span>)</div><div class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i < <span class="number">4</span>; i++ {</div><div class="line">        channels[i] = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</div><div class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</div><div class="line">            fmt.Println(<span class="string">"Not lock: "</span>, i)</div><div class="line">            mutex.Lock()</div><div class="line">            fmt.Println(<span class="string">"Locked: "</span>, i)</div><div class="line">            fmt.Println(<span class="string">"Unlock the lock: "</span>, i)</div><div class="line">            mutex.Unlock()</div><div class="line">            c <- i</div><div class="line">        }(i, channels[i])</div><div class="line">    }</div><div class="line">    time.Sleep(time.Second)</div><div class="line">    fmt.Println(<span class="string">"Unlock the lock"</span>)</div><div class="line">    mutex.Unlock()</div><div class="line">    time.Sleep(time.Second)</div><div class="line"></div><div class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> channels {</div><div class="line">        <-c</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></tbody></table></figure><p>程序输出：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Lock the lock</div><div class="line">The lock is locked</div><div class="line">Not lock:  0</div><div class="line">Not lock:  1</div><div class="line">Not lock:  2</div><div class="line">Not lock:  3</div><div class="line">Unlock the lock</div><div class="line">Locked:  0</div><div class="line">Unlock the lock:  0</div><div class="line">Locked:  2</div><div class="line">Unlock the lock:  2</div><div class="line">Locked:  3</div><div class="line">Unlock the lock:  3</div><div class="line">Locked:  1</div><div class="line">Unlock the lock:  1</div></pre></td></tr></tbody></table></figure><p></p><h3 id="Lock-和-RLock"><a href="#Lock-和-RLock" class="headerlink" title="Lock() 和 RLock()"></a>Lock() 和 RLock()</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"sync"</span></div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</div><div class="line">    <span class="keyword">var</span> mutex *sync.RWMutex</div><div class="line">    mutex = <span class="built_in">new</span>(sync.RWMutex)</div><div class="line">    fmt.Println(<span class="string">"Lock the lock"</span>)</div><div class="line">    mutex.Lock()</div><div class="line">    fmt.Println(<span class="string">"The lock is locked"</span>)</div><div class="line"></div><div class="line">    channels := <span class="built_in">make</span>([]<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">4</span>)</div><div class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i < <span class="number">4</span>; i++ {</div><div class="line">        channels[i] = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</div><div class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> {</div><div class="line">            fmt.Println(<span class="string">"Not read lock: "</span>, i)</div><div class="line">            mutex.RLock()</div><div class="line">            fmt.Println(<span class="string">"Read Locked: "</span>, i)</div><div class="line">            fmt.Println(<span class="string">"Unlock the read lock: "</span>, i)</div><div class="line">            time.Sleep(time.Second)</div><div class="line">            mutex.RUnlock()</div><div class="line">            c <- i</div><div class="line">        }(i, channels[i])</div><div class="line">    }</div><div class="line">    time.Sleep(time.Second)</div><div class="line">    fmt.Println(<span class="string">"Unlock the lock"</span>)</div><div class="line">    mutex.Unlock()</div><div class="line">    time.Sleep(time.Second)</div><div class="line"></div><div class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> channels {</div><div class="line">        <-c</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></tbody></table></figure><p>程序输出：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Lock the lock</div><div class="line">The lock is locked</div><div class="line">Not <span class="built_in">read</span> lock:  2</div><div class="line">Not <span class="built_in">read</span> lock:  3</div><div class="line">Not <span class="built_in">read</span> lock:  1</div><div class="line">Not <span class="built_in">read</span> lock:  0</div><div class="line">Unlock the lock</div><div class="line">Read Locked:  2</div><div class="line">Read Locked:  1</div><div class="line">Unlock the <span class="built_in">read</span> lock:  2</div><div class="line">Unlock the <span class="built_in">read</span> lock:  1</div><div class="line">Read Locked:  0</div><div class="line">Read Locked:  3</div><div class="line">Unlock the <span class="built_in">read</span> lock:  0</div><div class="line">Unlock the <span class="built_in">read</span> lock:  3</div></pre></td></tr></tbody></table></figure><p></p><h3 id="Unlock-使用之前不存在-Lock"><a href="#Unlock-使用之前不存在-Lock" class="headerlink" title="Unlock() 使用之前不存在 Lock()"></a>Unlock() 使用之前不存在 Lock()</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"sync"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</div><div class="line">    <span class="keyword">var</span> rwmutex *sync.RWMutex</div><div class="line">    rwmutex = <span class="built_in">new</span>(sync.RWMutex)</div><div class="line">    rwmutex.Unlock()</div><div class="line">}</div></pre></td></tr></tbody></table></figure><p>程序输出：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">panic: sync: Unlock of unlocked RWMutex</div></pre></td></tr></tbody></table></figure><p></p><h2 id="RWMutex-使用不当导致的死锁"><a href="#RWMutex-使用不当导致的死锁" class="headerlink" title="RWMutex 使用不当导致的死锁"></a>RWMutex 使用不当导致的死锁</h2><h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"sync"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</div><div class="line">    <span class="keyword">var</span> rwmutex *sync.RWMutex</div><div class="line">    rwmutex = <span class="built_in">new</span>(sync.RWMutex)</div><div class="line">    rwmutex.Lock()</div><div class="line">    rwmutex.Lock()</div><div class="line">}</div></pre></td></tr></tbody></table></figure><p>程序输出：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fatal error: all goroutines are asleep - deadlock!</div></pre></td></tr></tbody></table></figure><p></p><h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"sync"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</div><div class="line">    <span class="keyword">var</span> rwmutex *sync.RWMutex</div><div class="line">    rwmutex = <span class="built_in">new</span>(sync.RWMutex)</div><div class="line">    rwmutex.Lock()</div><div class="line">    rwmutex.RLock()</div><div class="line">}</div></pre></td></tr></tbody></table></figure><p>程序输出：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fatal error: all goroutines are asleep - deadlock!</div></pre></td></tr></tbody></table></figure><p></p><h3 id="RUnlock-之前不存在-RLock"><a href="#RUnlock-之前不存在-RLock" class="headerlink" title="RUnlock() 之前不存在 RLock()"></a>RUnlock() 之前不存在 RLock()</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"sync"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</div><div class="line">    <span class="keyword">var</span> rwmutex *sync.RWMutex</div><div class="line">    rwmutex = <span class="built_in">new</span>(sync.RWMutex)</div><div class="line">    rwmutex.RUnlock()</div><div class="line">}</div></pre></td></tr></tbody></table></figure><p>程序输出：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">panic: sync: RUnlock of unlocked RWMutex</div></pre></td></tr></tbody></table></figure><p></p><h3 id="RUnlock-个数多于-RLock"><a href="#RUnlock-个数多于-RLock" class="headerlink" title="RUnlock() 个数多于 RLock()"></a>RUnlock() 个数多于 RLock()</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"sync"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</div><div class="line">    <span class="keyword">var</span> rwmutex *sync.RWMutex</div><div class="line">    rwmutex = <span class="built_in">new</span>(sync.RWMutex)</div><div class="line">    rwmutex.RLock()</div><div class="line">    rwmutex.RLock()</div><div class="line">    rwmutex.RUnlock()</div><div class="line">    rwmutex.RUnlock()</div><div class="line">    rwmutex.RUnlock()</div><div class="line">}</div></pre></td></tr></tbody></table></figure><p>程序输出：<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">panic: sync: RUnlock of unlocked RWMutex</div></pre></td></tr></tbody></table></figure><p></p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;golang 中的 sync 包实现了两种锁：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Mutex：互斥锁&lt;/li&gt;
&lt;li&gt;RWMutex：读写锁，RWMutex 基于 Mutex 实现&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Kubernetes" scheme="https://www.flftuu.com/categories/Kubernetes/"/>
    
    
      <category term="go" scheme="https://www.flftuu.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>centos7安装kernel 4.x</title>
    <link href="https://www.flftuu.com/2020/04/15/centos7%E5%AE%89%E8%A3%85kernel-4-x/"/>
    <id>https://www.flftuu.com/2020/04/15/centos7安装kernel-4-x/</id>
    <published>2020-04-15T06:43:03.000Z</published>
    <updated>2020-06-05T08:45:12.015Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="Install-Linux-Kernel-4-4-5-LTS-in-CentOS-7"><a href="#Install-Linux-Kernel-4-4-5-LTS-in-CentOS-7" class="headerlink" title="Install Linux Kernel 4.4.5 LTS in CentOS 7"></a>Install Linux Kernel 4.4.5 LTS in CentOS 7</h2><p>I tested this tutorial on CentOS 7 64 bit edition. Although, these steps should work on RHEL 7.</p><p>Note: Since this kernel is just released, the latest kernel haven’t pushed into the ELRepo yet. It stills shows the 4.4.4 version. I think the latest kernel will be pushed to the repository in few hours.</p><p>To install the latest kernel, add ELRepo repository.</p><p>Add ELRepo GPG key:<br><a id="more"></a></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span></div></pre></td></tr></tbody></table></figure><p>Then, add ELRepo in CentOS 7 / RHEL 7 / Scientific Linux 7 using command:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm</span></div></pre></td></tr></tbody></table></figure><p>Enable ELRepo fastest mirror using by installing the following package:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># yum install yum-plugin-fastestmirror</span></div></pre></td></tr></tbody></table></figure><p>We have added the ELRepo. Now, it is time to install Linux kernel 4.4.1 LTS.</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># uname -r</span></div><div class="line"><span class="comment"># yum --enablerepo=elrepo-kernel install kernel-ml</span></div></pre></td></tr></tbody></table></figure><p>After installing the Kernel, Reboot your system and select the latest Kernel from the Grub boot menu.<br><img src="/2020/04/15/centos7安装kernel-4-x/CentOS-7-1-Running-Oracle-VM-VirtualBox_001.jpg" alt="kernel"></p><p>Check the Kernel version using command:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># uname -r</span></div></pre></td></tr></tbody></table></figure><p>Sample output:<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">4.4.4-1.el7.elrepo.x86_64</div></pre></td></tr></tbody></table></figure><p></p><p>Congratulation! Your CentOS 7 system is currently running on Kernel 4.4.4.</p><p>Have any problems after installing Linux Kernel 4.4.x? No worries, reboot your system. Select your previously working Kernel from the Boot menu.</p><p><img src="/2020/04/15/centos7安装kernel-4-x/CentOS-7-1-Running-Oracle-VM-VirtualBox_002.jpg" alt="kernel"></p><p>Then, remove the newly installed Kernel using command:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># yum remove kernel-ml</span></div></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Install-Linux-Kernel-4-4-5-LTS-in-CentOS-7&quot;&gt;&lt;a href=&quot;#Install-Linux-Kernel-4-4-5-LTS-in-CentOS-7&quot; class=&quot;headerlink&quot; title=&quot;Install Linux Kernel 4.4.5 LTS in CentOS 7&quot;&gt;&lt;/a&gt;Install Linux Kernel 4.4.5 LTS in CentOS 7&lt;/h2&gt;&lt;p&gt;I tested this tutorial on CentOS 7 64 bit edition. Although, these steps should work on RHEL 7.&lt;/p&gt;
&lt;p&gt;Note: Since this kernel is just released, the latest kernel haven’t pushed into the ELRepo yet. It stills shows the 4.4.4 version. I think the latest kernel will be pushed to the repository in few hours.&lt;/p&gt;
&lt;p&gt;To install the latest kernel, add ELRepo repository.&lt;/p&gt;
&lt;p&gt;Add ELRepo GPG key:&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Kubernetes" scheme="https://www.flftuu.com/categories/Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>理解Go Context机制</title>
    <link href="https://www.flftuu.com/2020/04/03/%E7%90%86%E8%A7%A3Go-Context%E6%9C%BA%E5%88%B6/"/>
    <id>https://www.flftuu.com/2020/04/03/理解Go-Context机制/</id>
    <published>2020-04-03T07:34:48.000Z</published>
    <updated>2020-06-03T09:05:08.367Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="1-什么是Context"><a href="#1-什么是Context" class="headerlink" title="1 什么是Context"></a>1 什么是Context</h2><p>最近在公司分析gRPC源码，proto文件生成的代码，接口函数第一个参数统一是ctx context.Context接口，公司不少同事都不了解这样设计的出发点是什么，其实我也不了解其背后的原理。今天趁着妮妲台风妹子正面登陆深圳，全市停工、停课、停业，在家休息找了一些资料研究把玩一把。</p><a id="more"></a><p>Context通常被译作上下文，它是一个比较抽象的概念。在公司技术讨论时也经常会提到上下文。一般理解为程序单元的一个运行状态、现场、快照，而翻译中上下又很好地诠释了其本质，上下上下则是存在上下层的传递，上会把内容传递给下。在Go语言中，程序单元也就指的是Goroutine。</p><p>每个Goroutine在执行之前，都要先知道程序当前的执行状态，通常将这些执行状态封装在一个Context变量中，传递给要执行的Goroutine中。上下文则几乎已经成为传递与请求同生存周期变量的标准方法。在网络编程下，当接收到一个网络请求Request，处理Request时，我们可能需要开启不同的Goroutine来获取数据与逻辑处理，即一个请求Request，会在多个Goroutine中处理。而这些Goroutine可能需要共享Request的一些信息；同时当Request被取消或者超时的时候，所有从这个Request创建的所有Goroutine也应该被结束。</p><h2 id="2-context包"><a href="#2-context包" class="headerlink" title="2 context包"></a>2 context包</h2><p>Go的设计者早考虑多个Goroutine共享数据，以及多Goroutine管理机制。Context介绍请参考Go Concurrency Patterns: Context，golang.org/x/net/context包就是这种机制的实现。</p><p>context包不仅实现了在程序单元之间共享状态变量的方法，同时能通过简单的方法，使我们在被调用程序单元的外部，通过设置ctx变量值，将过期或撤销这些信号传递给被调用的程序单元。在网络编程中，若存在A调用B的API, B再调用C的API，若A调用B取消，那也要取消B调用C，通过在A,B,C的API调用之间传递Context，以及判断其状态，就能解决此问题，这是为什么gRPC的接口中带上ctx context.Context参数的原因之一。</p><p>Go1.7(当前是RC2版本)已将原来的golang.org/x/net/context包挪入了标准库中，放在$GOROOT/src/context下面。标准库中net、net/http、os/exec都用到了context。同时为了考虑兼容，在原golang.org/x/net/context包下存在两个文件，go17.go是调用标准库的context包，而pre_go17.go则是之前的默认实现，其介绍请参考go程序包源码解读。</p><p>context包的核心就是Context接口，其定义如下：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> {</div><div class="line">    Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</div><div class="line">    Done() <-<span class="keyword">chan</span> <span class="keyword">struct</span>{}</div><div class="line">    Err() error</div><div class="line">    Value(key <span class="keyword">interface</span>{}) <span class="keyword">interface</span>{}</div><div class="line">}</div></pre></td></tr></tbody></table></figure><blockquote><ol><li>Deadline会返回一个超时时间，Goroutine获得了超时时间后，例如可以对某些io操作设定超时时间。</li></ol></blockquote><blockquote><ol start="2"><li>Done方法返回一个信道（channel），当Context被撤销或过期时，该信道是关闭的，即它是一个表示Context是否已关闭的信号。</li></ol></blockquote><blockquote><ol start="3"><li>当Done信道关闭后，Err方法表明Context被撤的原因。</li></ol></blockquote><blockquote><ol start="4"><li>Value可以让Goroutine共享一些数据，当然获得数据是协程安全的。但使用这些数据的时候要注意同步，比如返回了一个map，而这个map的读写则要加锁。</li></ol></blockquote><p>Context接口没有提供方法来设置其值和过期时间，也没有提供方法直接将其自身撤销。也就是说，Context不能改变和撤销其自身。那么该怎么通过Context传递改变后的状态呢？</p><h2 id="3-context使用"><a href="#3-context使用" class="headerlink" title="3 context使用"></a>3 context使用</h2><p>无论是Goroutine，他们的创建和调用关系总是像层层调用进行的，就像人的辈分一样，而更靠顶部的Goroutine应有办法主动关闭其下属的Goroutine的执行（不然程序可能就失控了）。为了实现这种关系，Context结构也应该像一棵树，叶子节点须总是由根节点衍生出来的。</p><p>要创建Context树，第一步就是要得到根节点，context.Background函数的返回值就是根节点：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span> <span class="title">Context</span></span></div></pre></td></tr></tbody></table></figure><p>该函数返回空的Context，该Context一般由接收请求的第一个Goroutine创建，是与进入请求对应的Context根节点，它不能被取消、没有值、也没有过期时间。它常常作为处理Request的顶层context存在。</p><p>有了根节点，又该怎么创建其它的子节点，孙节点呢？context包为我们提供了多个函数来创建他们：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span></div><div class="line"><span class="function"><span class="title">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span> <span class="params">(Context, CancelFunc)</span></span></div><div class="line"><span class="function"><span class="title">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span></div><div class="line"><span class="function"><span class="title">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key <span class="keyword">interface</span>{}, val <span class="keyword">interface</span>{})</span> <span class="title">Context</span></span></div></pre></td></tr></tbody></table></figure><p>函数都接收一个Context类型的参数parent，并返回一个Context类型的值，这样就层层创建出不同的节点。子节点是从复制父节点得到的，并且根据接收参数设定子节点的一些状态值，接着就可以将子节点传递给下层的Goroutine了。</p><p>再回到之前的问题：该怎么通过Context传递改变后的状态呢？使用Context的Goroutine无法取消某个操作，其实这也是符合常理的，因为这些Goroutine是被某个父Goroutine创建的，而理应只有父Goroutine可以取消操作。在父Goroutine中可以通过WithCancel方法获得一个cancel方法，从而获得cancel的权利。</p><p>第一个WithCancel函数，它是将父节点复制到子节点，并且还返回一个额外的CancelFunc函数类型变量，该函数类型的定义为：<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> CancelFunc <span class="function"><span class="keyword">func</span><span class="params">()</span></span></div></pre></td></tr></tbody></table></figure><p></p><p>调用CancelFunc对象将撤销对应的Context对象，这就是主动撤销Context的方法。在父节点的Context所对应的环境中，通过WithCancel函数不仅可创建子节点的Context，同时也获得了该节点Context的控制权，一旦执行该函数，则该节点Context就结束了，则子节点需要类似如下代码来判断是否已结束，并退出该Goroutine：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> {</div><div class="line">    <span class="keyword">case</span> <-cxt.Done():</div><div class="line">        <span class="comment">// do some clean...</span></div><div class="line">}</div></pre></td></tr></tbody></table></figure><p>WithDeadline函数的作用也差不多，它返回的Context类型值同样是parent的副本，但其过期时间由deadline和parent的过期时间共同决定。当parent的过期时间早于传入的deadline时间时，返回的过期时间应与parent相同。父节点过期时，其所有的子孙节点必须同时关闭；反之，返回的父节点的过期时间则为deadline。</p><p>WithTimeout函数与WithDeadline类似，只不过它传入的是从现在开始Context剩余的生命时长。他们都同样也都返回了所创建的子Context的控制权，一个CancelFunc类型的函数变量。</p><p>当顶层的Request请求函数结束后，我们就可以cancel掉某个context，从而层层Goroutine根据判断cxt.Done()来结束。</p><p>WithValue函数，它返回parent的一个副本，调用该副本的Value(key)方法将得到val。这样我们不光将根节点原有的值保留了，还在子孙节点中加入了新的值，注意若存在Key相同，则会被覆盖。</p><h3 id="3-1-小结"><a href="#3-1-小结" class="headerlink" title="3.1 小结"></a>3.1 小结</h3><p>context包通过构建树型关系的Context，来达到上一层Goroutine能对传递给下一层Goroutine的控制。对于处理一个Request请求操作，需要采用context来层层控制Goroutine，以及传递一些变量来共享。</p><blockquote><ol><li>Context对象的生存周期一般仅为一个请求的处理周期。即针对一个请求创建一个Context变量（它为Context树结构的根）；在请求处理结束后，撤销此ctx变量，释放资源。</li></ol></blockquote><blockquote><ol start="2"><li>每次创建一个Goroutine，要么将原有的Context传递给Goroutine，要么创建一个子Context并传递给Goroutine。</li></ol></blockquote><blockquote><ol start="3"><li>Context能灵活地存储不同类型、不同数目的值，并且使多个Goroutine安全地读写其中的值。</li></ol></blockquote><blockquote><ol start="4"><li>当通过父Context对象创建子Context对象时，可同时获得子Context的一个撤销函数，这样父Context对象的创建环境就获得了对子Context将要被传递到的Goroutine的撤销权。</li></ol></blockquote><ol start="5"><li>在子Context被传递到的goroutine中，应该对该子Context的Done信道（channel）进行监控，一旦该信道被关闭（即上层运行环境撤销了本goroutine的执行），应主动终止对当前请求信息的处理，释放资源并返回。</li></ol><h2 id="4-使用原则"><a href="#4-使用原则" class="headerlink" title="4 使用原则"></a>4 使用原则</h2><p>Programs that use Contexts should follow these rules to keep interfaces consistent across packages and enable static analysis tools to check context propagation:<br>使用Context的程序包需要遵循如下的原则来满足接口的一致性以及便于静态分析。</p><blockquote><p>. Do not store Contexts inside a struct type; instead, pass a Context explicitly to each function that needs it. The Context should be the first parameter, typically named ctx；不要把Context存在一个结构体当中，显式地传入函数。Context变量需要作为第一个参数使用，一般命名为ctx；</p></blockquote><blockquote><p>. Do not pass a nil Context, even if a function permits it. Pass context.TODO if you are unsure about which Context to use；即使方法允许，也不要传入一个nil的Context，如果你不确定你要用什么Context的时候传一个context.TODO；</p></blockquote><blockquote><p>. Use context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions；使用context的Value相关方法只应该用于在程序和接口中传递的和请求相关的元数据，不要用它来传递一些可选的参数；</p></blockquote><blockquote><p>. The same Context may be passed to functions running in different goroutines; Contexts are safe for simultaneous use by multiple goroutines；同样的Context可以用来传递到不同的goroutine中，Context在多个goroutine中是安全的；</p></blockquote><hr><h2 id="Context-原理"><a href="#Context-原理" class="headerlink" title="Context 原理"></a>Context 原理</h2><p>Context 的调用应该是链式的，通过WithCancel，WithDeadline，WithTimeout或WithValue派生出新的 Context。当父 Context 被取消时，其派生的所有 Context 都将取消。</p><p>通过context.WithXXX都将返回新的 Context 和 CancelFunc。调用 CancelFunc 将取消子代，移除父代对子代的引用，并且停止所有定时器。未能调用 CancelFunc 将泄漏子代，直到父代被取消或定时器触发。go vet工具检查所有流程控制路径上使用 CancelFuncs。</p><h2 id="遵循规则"><a href="#遵循规则" class="headerlink" title="遵循规则"></a>遵循规则</h2><p>遵循以下规则，以保持包之间的接口一致，并启用静态分析工具以检查上下文传播。</p><blockquote><ol><li>不要将 Contexts 放入结构体，相反context应该作为第一个参数传入，命名为ctx。 func DoSomething（ctx context.Context，arg Arg）error { // … use ctx … }</li><li>即使函数允许，也不要传入nil的 Context。如果不知道用哪种 Context，可以使用context.TODO()。</li><li>使用context的Value相关方法只应该用于在程序和接口中传递的和请求相关的元数据，不要用它来传递一些可选的参数</li><li>相同的 Context 可以传递给在不同的goroutine；Context 是并发安全的。</li></ol></blockquote><h2 id="Context-包"><a href="#Context-包" class="headerlink" title="Context 包"></a>Context 包</h2><p>Context 结构体。<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// A Context carries a deadline, cancelation signal, and request-scoped values</span></div><div class="line"><span class="comment">// across API boundaries. Its methods are safe for simultaneous use by multiple</span></div><div class="line"><span class="comment">// goroutines.</span></div><div class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> {</div><div class="line">    <span class="comment">// Done returns a channel that is closed when this Context is canceled</span></div><div class="line">    <span class="comment">// or times out.</span></div><div class="line">    Done() <-<span class="keyword">chan</span> <span class="keyword">struct</span>{}</div><div class="line"></div><div class="line">    <span class="comment">// Err indicates why this context was canceled, after the Done channel</span></div><div class="line">    <span class="comment">// is closed.</span></div><div class="line">    Err() error</div><div class="line"></div><div class="line">    <span class="comment">// Deadline returns the time when this Context will be canceled, if any.</span></div><div class="line">    Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</div><div class="line"></div><div class="line">    <span class="comment">// Value returns the value associated with key or nil if none.</span></div><div class="line">    Value(key <span class="keyword">interface</span>{}) <span class="keyword">interface</span>{}</div><div class="line">}</div></pre></td></tr></tbody></table></figure><p></p><blockquote><ol><li>Done()，返回一个channel。当times out或者调用cancel方法时，将会close掉。</li><li>Err()，返回一个错误。该context为什么被取消掉。</li><li>Deadline()，返回截止时间和ok。</li><li>Value()，返回值。</li></ol></blockquote><p>所有方法<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span> <span class="title">Context</span></span></div><div class="line"><span class="function"><span class="title">func</span> <span class="title">TODO</span><span class="params">()</span> <span class="title">Context</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="title">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span></div><div class="line"><span class="function"><span class="title">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span> <span class="params">(Context, CancelFunc)</span></span></div><div class="line"><span class="function"><span class="title">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span></div><div class="line"><span class="function"><span class="title">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>{})</span> <span class="title">Context</span></span></div></pre></td></tr></tbody></table></figure><p></p><p>上面可以看到Context是一个接口，想要使用就得实现其方法。在context包内部已经为我们实现好了两个空的Context，可以通过调用Background()和TODO()方法获取。一般的将它们作为Context的根，往下派生。</p><h2 id="WithCancel-例子"><a href="#WithCancel-例子" class="headerlink" title="WithCancel 例子"></a>WithCancel 例子</h2><p>WithCancel 以一个新的 Done channel 返回一个父 Context 的拷贝。<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="number">229</span>  <span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span> {</div><div class="line"><span class="number">230</span>      c := newCancelCtx(parent)</div><div class="line"><span class="number">231</span>      propagateCancel(parent, &c)</div><div class="line"><span class="number">232</span>      <span class="keyword">return</span> &c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> { c.cancel(<span class="literal">true</span>, Canceled) }</div><div class="line"><span class="number">233</span>  }</div><div class="line"><span class="number">234</span>  </div><div class="line"><span class="number">235</span>  <span class="comment">// newCancelCtx returns an initialized cancelCtx.</span></div><div class="line"><span class="number">236</span>  <span class="function"><span class="keyword">func</span> <span class="title">newCancelCtx</span><span class="params">(parent Context)</span> <span class="title">cancelCtx</span></span> {</div><div class="line"><span class="number">237</span>      <span class="keyword">return</span> cancelCtx{</div><div class="line"><span class="number">238</span>          Context: parent,</div><div class="line"><span class="number">239</span>          done:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{}),</div><div class="line"><span class="number">240</span>      }</div><div class="line"><span class="number">241</span>  }</div></pre></td></tr></tbody></table></figure><p></p><p>此示例演示使用一个可取消的上下文，以防止 goroutine 泄漏。示例函数结束时，defer 调用 cancel 方法，gen goroutine 将返回而不泄漏。<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"context"</span></div><div class="line">    <span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</div><div class="line">    <span class="comment">// gen generates integers in a separate goroutine and</span></div><div class="line">    <span class="comment">// sends them to the returned channel.</span></div><div class="line">    <span class="comment">// The callers of gen need to cancel the context once</span></div><div class="line">    <span class="comment">// they are done consuming generated integers not to leak</span></div><div class="line">    <span class="comment">// the internal goroutine started by gen.</span></div><div class="line">    gen := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span> <-<span class="title">chan</span> <span class="title">int</span></span> {</div><div class="line">        dst := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</div><div class="line">        n := <span class="number">1</span></div><div class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</div><div class="line">            <span class="keyword">for</span> {</div><div class="line">                <span class="keyword">select</span> {</div><div class="line">                <span class="keyword">case</span> <-ctx.Done():</div><div class="line">                    <span class="keyword">return</span> <span class="comment">// returning not to leak the goroutine</span></div><div class="line">                <span class="keyword">case</span> dst <- n:</div><div class="line">                    n++</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }()</div><div class="line">        <span class="keyword">return</span> dst</div><div class="line">    }</div><div class="line"></div><div class="line">    ctx, cancel := context.WithCancel(context.Background())</div><div class="line">    <span class="keyword">defer</span> cancel() <span class="comment">// cancel when we are finished consuming integers</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> n := <span class="keyword">range</span> gen(ctx) {</div><div class="line">        fmt.Println(n)</div><div class="line">        <span class="keyword">if</span> n == <span class="number">5</span> {</div><div class="line">            <span class="keyword">break</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></tbody></table></figure><p></p><p>WithDeadline 例子<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="number">369</span>  <span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span> <span class="params">(Context, CancelFunc)</span></span> {</div><div class="line"><span class="number">370</span>      <span class="keyword">if</span> cur, ok := parent.Deadline(); ok && cur.Before(deadline) {</div><div class="line"><span class="number">371</span>          <span class="comment">// The current deadline is already sooner than the new one.</span></div><div class="line"><span class="number">372</span>          <span class="keyword">return</span> WithCancel(parent)</div><div class="line"><span class="number">373</span>      }</div><div class="line"><span class="number">374</span>      c := &timerCtx{</div><div class="line"><span class="number">375</span>          cancelCtx: newCancelCtx(parent),</div><div class="line"><span class="number">376</span>          deadline:  deadline,</div><div class="line"><span class="number">377</span>      }</div><div class="line">......</div></pre></td></tr></tbody></table></figure><p></p><p>可以清晰的看到，当派生出的子 Context 的deadline在父Context之后，直接返回了一个父Context的拷贝。故语义上等效为父。</p><p>WithDeadline 的最后期限调整为不晚于 d 返回父上下文的副本。如果父母的截止日期已经早于 d，WithDeadline （父，d） 是在语义上等效为父。返回的上下文完成的通道关闭的最后期限期满后，返回的取消函数调用时，或当父上下文完成的通道关闭，以先发生者为准。</p><p>看看官方例子：<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"context"</span></div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</div><div class="line">    d := time.Now().Add(<span class="number">50</span> * time.Millisecond)</div><div class="line">    ctx, cancel := context.WithDeadline(context.Background(), d)</div><div class="line"></div><div class="line">    <span class="comment">// Even though ctx will be expired, it is good practice to call its</span></div><div class="line">    <span class="comment">// cancelation function in any case. Failure to do so may keep the</span></div><div class="line">    <span class="comment">// context and its parent alive longer than necessary.</span></div><div class="line">    <span class="keyword">defer</span> cancel()</div><div class="line"></div><div class="line">    <span class="keyword">select</span> {</div><div class="line">    <span class="keyword">case</span> <-time.After(<span class="number">1</span> * time.Second):</div><div class="line">        fmt.Println(<span class="string">"overslept"</span>)</div><div class="line">    <span class="keyword">case</span> <-ctx.Done():</div><div class="line">        fmt.Println(ctx.Err())</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></tbody></table></figure><p></p><p>WithTimeout 例子<br>WithTimeout 返回 WithDeadline(parent, time.Now().Add(timeout))。<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">436</span>  <span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span> {</div><div class="line"><span class="number">437</span>      <span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</div><div class="line"><span class="number">438</span>  }</div></pre></td></tr></tbody></table></figure><p></p><p>看看官方例子：<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"context"</span></div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</div><div class="line">    <span class="comment">// Pass a context with a timeout to tell a blocking function that it</span></div><div class="line">    <span class="comment">// should abandon its work after the timeout elapses.</span></div><div class="line">    ctx, cancel := context.WithTimeout(context.Background(), <span class="number">50</span>*time.Millisecond)</div><div class="line">    <span class="keyword">defer</span> cancel()</div><div class="line"></div><div class="line">    <span class="keyword">select</span> {</div><div class="line">    <span class="keyword">case</span> <-time.After(<span class="number">1</span> * time.Second):</div><div class="line">        fmt.Println(<span class="string">"overslept"</span>)</div><div class="line">    <span class="keyword">case</span> <-ctx.Done():</div><div class="line">        fmt.Println(ctx.Err()) <span class="comment">// prints "context deadline exceeded"</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></tbody></table></figure><p></p><p>WithValue 例子<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="number">454</span>  <span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>{})</span> <span class="title">Context</span></span> {</div><div class="line"><span class="number">454</span>      <span class="keyword">if</span> key == <span class="literal">nil</span> {</div><div class="line"><span class="number">455</span>          <span class="built_in">panic</span>(<span class="string">"nil key"</span>)</div><div class="line"><span class="number">456</span>      }</div><div class="line"><span class="number">457</span>      <span class="keyword">if</span> !reflect.TypeOf(key).Comparable() {</div><div class="line"><span class="number">458</span>          <span class="built_in">panic</span>(<span class="string">"key is not comparable"</span>)</div><div class="line"><span class="number">459</span>      }</div><div class="line"><span class="number">460</span>      <span class="keyword">return</span> &valueCtx{parent, key, val}</div><div class="line"><span class="number">461</span>  }</div></pre></td></tr></tbody></table></figure><p></p><p>WithValue 返回的父与键关联的值在 val 的副本。</p><p>使用上下文值仅为过渡进程和 Api 的请求范围的数据，而不是将可选参数传递给函数。</p><p>提供的键必须是可比性和应该不是字符串类型或任何其他内置的类型以避免包使用的上下文之间的碰撞。WithValue 用户应该定义自己的键的类型。为了避免分配分配给接口 {} 时，上下文键经常有具体类型结构 {}。另外，导出的上下文关键变量静态类型应该是一个指针或接口。</p><p>看看官方例子：<br></p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"context"</span></div><div class="line">    <span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</div><div class="line">    <span class="keyword">type</span> favContextKey <span class="keyword">string</span></div><div class="line"></div><div class="line">    f := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, k favContextKey)</span></span> {</div><div class="line">        <span class="keyword">if</span> v := ctx.Value(k); v != <span class="literal">nil</span> {</div><div class="line">            fmt.Println(<span class="string">"found value:"</span>, v)</div><div class="line">            <span class="keyword">return</span></div><div class="line">        }</div><div class="line">        fmt.Println(<span class="string">"key not found:"</span>, k)</div><div class="line">    }</div><div class="line"></div><div class="line">    k := favContextKey(<span class="string">"language"</span>)</div><div class="line">    ctx := context.WithValue(context.Background(), k, <span class="string">"Go"</span>)</div><div class="line"></div><div class="line">    f(ctx, k)</div><div class="line">    f(ctx, favContextKey(<span class="string">"color"</span>))</div><div class="line">}</div></pre></td></tr></tbody></table></figure><p></p><p>参考：<br>[1] <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmdvbGFuZy5vcmcvY29udGV4dA==" title="https://blog.golang.org/context">https://blog.golang.org/context<i class="fa fa-external-link"></i></span><br>[2] <span class="exturl" data-url="aHR0cDovL2Jsb2cuZ29sYW5nLm9yZy9waXBlbGluZXM=" title="http://blog.golang.org/pipelines">http://blog.golang.org/pipelines<i class="fa fa-external-link"></i></span><br>[3] <span class="exturl" data-url="aHR0cDovL3N0dWR5Z29sYW5nLmNvbS9hcnRpY2xlcy81MTMx" title="http://studygolang.com/articles/5131">http://studygolang.com/articles/5131<i class="fa fa-external-link"></i></span><br>[4] <span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3J5YW4vYXJ0aWNsZS9kZXRhaWxzLzUxOTY5MTI5" title="http://blog.csdn.net/sryan/article/details/51969129">http://blog.csdn.net/sryan/article/details/51969129<i class="fa fa-external-link"></i></span><br>[5] <span class="exturl" data-url="aHR0cHM6Ly9wZXRlci5ib3VyZ29uLm9yZy9ibG9nLzIwMTYvMDcvMTEvY29udGV4dC5odG1s" title="https://peter.bourgon.org/blog/2016/07/11/context.html">https://peter.bourgon.org/blog/2016/07/11/context.html<i class="fa fa-external-link"></i></span><br>[6] <span class="exturl" data-url="aHR0cDovL3d3dy50dWljb29sLmNvbS9hcnRpY2xlcy92YWllQWJR" title="http://www.tuicool.com/articles/vaieAbQ">http://www.tuicool.com/articles/vaieAbQ<i class="fa fa-external-link"></i></span></p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-什么是Context&quot;&gt;&lt;a href=&quot;#1-什么是Context&quot; class=&quot;headerlink&quot; title=&quot;1 什么是Context&quot;&gt;&lt;/a&gt;1 什么是Context&lt;/h2&gt;&lt;p&gt;最近在公司分析gRPC源码，proto文件生成的代码，接口函数第一个参数统一是ctx context.Context接口，公司不少同事都不了解这样设计的出发点是什么，其实我也不了解其背后的原理。今天趁着妮妲台风妹子正面登陆深圳，全市停工、停课、停业，在家休息找了一些资料研究把玩一把。&lt;/p&gt;
    
    </summary>
    
      <category term="Kubernetes" scheme="https://www.flftuu.com/categories/Kubernetes/"/>
    
    
      <category term="Go" scheme="https://www.flftuu.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>docker看veth对</title>
    <link href="https://www.flftuu.com/2020/04/01/docker%E7%9C%8Bveth%E5%AF%B9/"/>
    <id>https://www.flftuu.com/2020/04/01/docker看veth对/</id>
    <published>2020-04-01T09:40:13.000Z</published>
    <updated>2020-05-27T09:42:08.216Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="找到网卡对应的方式，在主机上执行如下命令"><a href="#找到网卡对应的方式，在主机上执行如下命令" class="headerlink" title="找到网卡对应的方式，在主机上执行如下命令"></a>找到网卡对应的方式，在主机上执行如下命令</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it <container-name> bash -c <span class="string">'cat /sys/class/net/eth0/iflink'</span></div><div class="line"></div><div class="line"><span class="comment"># 假设返回 12</span></div><div class="line">grep -l 12 /sys/class/net/veth*/ifindex</div><div class="line"><span class="comment"># 此时会有如下类似返回</span></div><div class="line">/sys/class/net/veth11d4238/ifindex</div><div class="line"><span class="comment"># veth11d4238 即主机上的另一半</span></div></pre></td></tr></tbody></table></figure><a id="more"></a><p>做成一个脚本 vethfinder</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="keyword">for</span> container <span class="keyword">in</span> $(docker ps -q); <span class="keyword">do</span></div><div class="line">    iflink=`docker <span class="built_in">exec</span> -it <span class="variable">$container</span> bash -c <span class="string">'cat /sys/class/net/eth0/iflink'</span>`</div><div class="line">    iflink=`<span class="built_in">echo</span> <span class="variable">$iflink</span>|tr -d <span class="string">'\r'</span>`</div><div class="line">    veth=`grep -l <span class="variable">$iflink</span> /sys/class/net/veth*/ifindex`</div><div class="line">    veth=`<span class="built_in">echo</span> <span class="variable">$veth</span>|sed -e <span class="string">'s;^.*net/\(.*\)/ifindex$;\1;'</span>`</div><div class="line">    <span class="built_in">echo</span> <span class="variable">$container</span>:<span class="variable">$veth</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></tbody></table></figure><p>执行</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ docker ps -q</div><div class="line">c4d8096eff43</div><div class="line">34ac6e9f1e6e</div><div class="line">d5a2aa5f3de3</div><div class="line"> </div><div class="line">$ sudo ./vethfinder</div><div class="line">c4d8096eff43:veth11d4238</div><div class="line">34ac6e9f1e6e:veth7d52cd1</div><div class="line">d5a2aa5f3de3:vethe46073d</div></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;找到网卡对应的方式，在主机上执行如下命令&quot;&gt;&lt;a href=&quot;#找到网卡对应的方式，在主机上执行如下命令&quot; class=&quot;headerlink&quot; title=&quot;找到网卡对应的方式，在主机上执行如下命令&quot;&gt;&lt;/a&gt;找到网卡对应的方式，在主机上执行如下命令&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;docker &lt;span class=&quot;built_in&quot;&gt;exec&lt;/span&gt; -it &amp;lt;container-name&amp;gt; bash -c &lt;span class=&quot;string&quot;&gt;&#39;cat /sys/class/net/eth0/iflink&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 假设返回 12&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;grep -l 12 /sys/class/net/veth*/ifindex&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 此时会有如下类似返回&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;/sys/class/net/veth11d4238/ifindex&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# veth11d4238 即主机上的另一半&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Kubernetes" scheme="https://www.flftuu.com/categories/Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>python 图片文字识别+二维码识别</title>
    <link href="https://www.flftuu.com/2020/03/11/python-%E5%9B%BE%E7%89%87%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB-%E4%BA%8C%E7%BB%B4%E7%A0%81%E8%AF%86%E5%88%AB/"/>
    <id>https://www.flftuu.com/2020/03/11/python-图片文字识别-二维码识别/</id>
    <published>2020-03-11T06:55:26.000Z</published>
    <updated>2020-05-22T09:39:07.313Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="文字识别"><a href="#文字识别" class="headerlink" title="文字识别"></a>文字识别</h1><p>python的pytesseract为文字识别提供了很好的支持。整个实现只需要一行关键代码即可。</p><h2 id="前提安装"><a href="#前提安装" class="headerlink" title="前提安装"></a>前提安装</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">yum install -y tesseract-langpack-chi_sim tesseract-langpack-chi_tra tesseract</div><div class="line">pip install pytesseract</div></pre></td></tr></tbody></table></figure><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Imageimport</div><div class="line"><span class="keyword">import</span> pytesseract</div><div class="line">text=pytesseract.image_to_string(Image.open(file_path), lang=<span class="string">'chi_sim'</span>)</div><div class="line">print(text)</div></pre></td></tr></tbody></table></figure><p>识别语言： 中文简体(chi_sim), 繁体(chi_tra)</p><a id="more"></a><h1 id="二维码识别"><a href="#二维码识别" class="headerlink" title="二维码识别"></a>二维码识别</h1><p>在没接触 Python 之前，曾使用 Zbar 的客户端进行识别，测了大概几百张相对模糊的图片，Zbar的识别速度要快很多，识别率也比 Zxing 稍微准确那边一丢丢，但是，稍微模糊一点就无法识别。</p><h2 id="前提安装-1"><a href="#前提安装-1" class="headerlink" title="前提安装"></a>前提安装</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 升级 pip 并安装第三方库</span></div><div class="line">pip install -U pip</div><div class="line">pip install Pillow</div><div class="line">pip install pyzbar</div><div class="line">pip install qrcode</div></pre></td></tr></tbody></table></figure><h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Imageimport</div><div class="line"><span class="keyword">import</span> pyzbar.pyzbar <span class="keyword">as</span> pyzbar</div><div class="line"></div><div class="line">bar_codes = pyzbar.decode(Image.open(file_path))</div><div class="line"><span class="keyword">for</span> bar_code <span class="keyword">in</span> bar_codes:</div><div class="line">    bar_code_info += bar_code.data.decode(<span class="string">"utf-8"</span>)</div><div class="line">print(bar_code_info)</div></pre></td></tr></tbody></table></figure><h1 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h1><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> io</div><div class="line"><span class="keyword">import</span> requests</div><div class="line"><span class="keyword">import</span> pytesseract</div><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</div><div class="line"><span class="keyword">import</span> pyzbar.pyzbar <span class="keyword">as</span> pyzbar</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_image_qrcode</span><span class="params">(image)</span>:</span></div><div class="line">    bar_code_info = <span class="string">""</span></div><div class="line">    buf_image = io.BytesIO()</div><div class="line">    ir = requests.get(image, stream=<span class="keyword">True</span>)</div><div class="line">    <span class="keyword">if</span> ir.ok:</div><div class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> ir:</div><div class="line">            buf_image.write(chunk)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> bar_code_info</div><div class="line">    img = Image.open(buf_image)</div><div class="line">    <span class="keyword">if</span> img:</div><div class="line">        bar_codes = pyzbar.decode(img)</div><div class="line">        <span class="keyword">for</span> bar_code <span class="keyword">in</span> bar_codes:</div><div class="line">            bar_code_info += bar_code.data.decode(<span class="string">"utf-8"</span>)</div><div class="line"></div><div class="line">    <span class="keyword">if</span> len(bar_code_info) > <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> bar_code_info</div><div class="line"></div><div class="line">    <span class="keyword">if</span> img:</div><div class="line">        bar_code_info = pytesseract.image_to_string(img, lang=<span class="string">'chi_tra'</span>)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> bar_code_info</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    image = <span class="string">"https://pic2.zhimg.com/80/v2-50eaea949ac63de5d5a84813d9efe491_720w.jpg"</span></div><div class="line">    image_info = check_image_qrcode(image)</div><div class="line">    <span class="keyword">if</span> len(image_info) == <span class="number">0</span> :</div><div class="line">        print(<span class="string">"11111"</span>)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        print(image_info)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    main()</div></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;文字识别&quot;&gt;&lt;a href=&quot;#文字识别&quot; class=&quot;headerlink&quot; title=&quot;文字识别&quot;&gt;&lt;/a&gt;文字识别&lt;/h1&gt;&lt;p&gt;python的pytesseract为文字识别提供了很好的支持。整个实现只需要一行关键代码即可。&lt;/p&gt;
&lt;h2 id=&quot;前提安装&quot;&gt;&lt;a href=&quot;#前提安装&quot; class=&quot;headerlink&quot; title=&quot;前提安装&quot;&gt;&lt;/a&gt;前提安装&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;yum install -y tesseract-langpack-chi_sim tesseract-langpack-chi_tra tesseract&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;pip install pytesseract&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;代码示例&quot;&gt;&lt;a href=&quot;#代码示例&quot; class=&quot;headerlink&quot; title=&quot;代码示例&quot;&gt;&lt;/a&gt;代码示例&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; PIL &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Imageimport&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; pytesseract&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;text=pytesseract.image_to_string(Image.open(file_path), lang=&lt;span class=&quot;string&quot;&gt;&#39;chi_sim&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;print(text)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;识别语言： 中文简体(chi_sim), 繁体(chi_tra)&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://www.flftuu.com/categories/Python/"/>
    
    
      <category term="python" scheme="https://www.flftuu.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>集群日志审计</title>
    <link href="https://www.flftuu.com/2020/03/10/%E9%9B%86%E7%BE%A4%E6%97%A5%E5%BF%97%E5%AE%A1%E8%AE%A1/"/>
    <id>https://www.flftuu.com/2020/03/10/集群日志审计/</id>
    <published>2020-03-10T07:55:25.000Z</published>
    <updated>2020-05-06T08:03:11.594Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><a id="more"></a><h1 id="集群做了什么？产生了什么影响？"><a href="#集群做了什么？产生了什么影响？" class="headerlink" title="集群做了什么？产生了什么影响？"></a>集群做了什么？产生了什么影响？</h1><p>在容器引擎的日常运维中，经常遇到客户反馈线上问题，例如: cloud-controller-manager 服务无法启动，集群初始化卡状态，kubectl top no 命令返回错误，master节点某些pod被kill掉等；值班同学遇到这些问题时，通常会进入集群各个节点查看服务日志，找到产生问题的原因；经过一段时间对值班反馈问题的整理，发现线上服务出现异常的根本原因主要集中在以下几类： 1. 客户修改或删除集群服务配置文件  2. 客户勿删集群资源 3. 节点系统服务异常或资源不足 ；为了更加便捷高效的排查问题，我们引入了集群审计，用于追踪系统日志，配置文件变更，k8s资源操作，将集群在某个时间段内做了什么，产生了什么影响，变得一目了然。</p><h1 id="服务架构"><a href="#服务架构" class="headerlink" title="服务架构"></a>服务架构</h1><p><img src="/2020/03/10/集群日志审计/审计.jpg" alt="1"></p><h1 id="集群审计数据源"><a href="#集群审计数据源" class="headerlink" title="集群审计数据源"></a>集群审计数据源</h1><h3 id="Kubernetes-Audit"><a href="#Kubernetes-Audit" class="headerlink" title="Kubernetes-Audit"></a>Kubernetes-Audit</h3><pre><code>kubernetes资源操作追踪审计日志</code></pre><h3 id="启动和配置"><a href="#启动和配置" class="headerlink" title="启动和配置"></a>启动和配置</h3><pre><code>kube-apiserver源生支持kubernetes集群操作审计功能，在启动kube-apiserver服务时加入以下参数即可：</code></pre><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">--audit-policy-file=/etc/kubernetes/audit-policy.yaml  <span class="comment"># 指定审计策略配置文件路径</span></div><div class="line">--audit-log-path=/var/<span class="built_in">log</span>/kubernetes/audit.log         <span class="comment"># 指定审计日志输出路径</span></div><div class="line">--audit-log-maxage=7                                   <span class="comment"># 审计日志保留天数</span></div><div class="line">--audit-log-maxbackup=4                                <span class="comment"># 审计日志备份数量</span></div><div class="line">--audit-log-maxsize=10                                 <span class="comment"># 审计日志文件大小，文件超过指定大小后将循环覆盖写入</span></div></pre></td></tr></tbody></table></figure><h3 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/kubernetes/manifests/kube-apiserver.yaml 展开源码</div></pre></td></tr></tbody></table></figure><h3 id="审计策略文件"><a href="#审计策略文件" class="headerlink" title="审计策略文件"></a>审计策略文件</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/kubernetes/audit-policy.yaml 展开源码</div></pre></td></tr></tbody></table></figure><h3 id="Inotifywait"><a href="#Inotifywait" class="headerlink" title="Inotifywait"></a>Inotifywait</h3><pre><code>inotify日志，记录集群节点文件变更（包括：创建，修改，删除，移动操作）</code></pre><h3 id="启动和配置-1"><a href="#启动和配置-1" class="headerlink" title="启动和配置"></a>启动和配置</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/bin/inotifywait -mrq -d -o /var/<span class="built_in">log</span>/inotify.log --timefmt <span class="string">'%Y-%m-%d %H:%M:%S'</span> --format <span class="string">'{"datetime": "%T", "event": "%e", "fpath": "%w%f"}'</span> -e create,delete,modify,move --exclude <span class="string">"(.swp|.inc|.svn|.rar|.tar.gz|.gz|.txt|.zip|.bak|.log|sed*[[:alpha:]])"</span> /etc</div></pre></td></tr></tbody></table></figure><h3 id="Syslog"><a href="#Syslog" class="headerlink" title="Syslog"></a>Syslog</h3><pre><code>linux系统日志</code></pre><h3 id="Filebeat"><a href="#Filebeat" class="headerlink" title="Filebeat"></a>Filebeat</h3><pre><code>Filebeat是一个轻量级日志传输Agent，可以将指定日志转发到Logstash、Elasticsearch、Kafka、Redis等中。Filebeat占用资源少，而且安装配置也比较简单，支持目前各类主流OS及Docker平台。</code></pre><h3 id="启动和配置-2"><a href="#启动和配置-2" class="headerlink" title="启动和配置"></a>启动和配置</h3><pre><code>/etc/filebeat/filebeat.yml 展开源码</code></pre><h1 id="审计日志汇总展示"><a href="#审计日志汇总展示" class="headerlink" title="审计日志汇总展示"></a>审计日志汇总展示</h1><h2 id="Kibana使用"><a href="#Kibana使用" class="headerlink" title="Kibana使用"></a>Kibana使用</h2><p>Kibana服务地址：<span class="exturl" data-url="aHR0cDovL2tpYmFuYS5rY2Uua3N5dW4uY29tOjg2MDEvYXBwL2tpYmFuYSMvaG9tZT9fZz0oKQ==" title="http://kibana.kce.ksyun.com:8601/app/kibana#/home?_g=()">http://kibana.kce.ksyun.com:8601/app/kibana#/home?_g=()<i class="fa fa-external-link"></i></span></p><p>进入Kibana页面后，导航栏中选择”Discover” => 在index下拉菜单中选择 “kce-online-audit-*” => 在页面最上面的输入框中输入 “cluster_uuid: ${cluster_uuid}” 按集群uuid过滤审计日志 => “回车”进行搜索查询<br><img src="/2020/03/10/集群日志审计/image2019-10-8_17-31-8.png" alt="2"></p><p>审计日志包含三个数据源，在审计中使用”tags”进行标识区分； objectRef.resource和verb 是 kube-apiserver字段，用于快速查看集群中哪些资源做了什么操作； event和fpath 是 inotify字段，用于快速查看哪些文件产生了哪些变更事件<br><img src="/2020/03/10/集群日志审计/image2019-10-8_17-40-17.png" alt="1"></p><p>由于syslog的message字段内容数据量大小不一致，切内容非格式化，故没有在Kibana展示模板进行单独配置，如果需要批量查看syslog审计日志可按tags过滤，并定义查看指定审计字段</p><p><img src="/2020/03/10/集群日志审计/image2019-10-8_17-49-21.png" alt="1"></p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;集群做了什么？产生了什么影响？&quot;&gt;&lt;a href=&quot;#集群做了什么？产生了什么影响？&quot; class=&quot;headerlink&quot; title=&quot;集群做了什么？产生了什么影响？&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="Kubernetes" scheme="https://www.flftuu.com/categories/Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>多集群资源统一管理之Federation v2</title>
    <link href="https://www.flftuu.com/2020/03/08/%E5%A4%9A%E9%9B%86%E7%BE%A4%E8%B5%84%E6%BA%90%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86%E4%B9%8BFederation-v2/"/>
    <id>https://www.flftuu.com/2020/03/08/多集群资源统一管理之Federation-v2/</id>
    <published>2020-03-08T07:31:42.000Z</published>
    <updated>2020-05-06T08:02:58.551Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Kubernetes Cluster Federation 又名 KubeFed 或 Federtation v2，是 Kubernetes SIG Multi-Cluster 团队新提出的集群联邦架构。新架构在 Federation v1 基础之上，简化扩展 Federated API过程，并加强跨集群服务发现与编排的功能。</p><p>KubeFed 是Kubernetes官方多集群联邦解决方案。它允许用户使用在“Host cluster”中定义的一组简单的APIs，在多个Kubernetes集群中联合统一调度工作负载。</p><p>KubeFed 与v1版本使用一套独立的Federation APIs不同，它创建和扩展了一套自定义资源。</p><p>在 KubeFed 设计之初，有两个最重要的核心理念是其希望实现的，分别为 Modularization（模块化）和 Customizable（定制化）。这两个理念是希望 KubeFed 能够跟随着 Kubernetes 生态发展，并与之保持相容性和扩展性。</p><p>与 v1 版本相比，KubeFed 最大的改变是将 API Server 移除，并通过 CRD 机制来完成 Federated Resources 的扩充，KubeFed Controller 负责管理这些 CRD，并实现同步 Resources 、跨集群编排等功能。<br><a id="more"></a><br><img src="/2020/03/08/多集群资源统一管理之Federation-v2/KubeFedv2-arch.png" alt="1"></p><h1 id="概念及原理"><a href="#概念及原理" class="headerlink" title="概念及原理"></a>概念及原理</h1><h2 id="Host-cluster"><a href="#Host-cluster" class="headerlink" title="Host cluster"></a>Host cluster</h2><p>用于提供 KubeFed API和控制平面的集群，控制平面中配置了 KubeFedConfig 和 KubeFedCluster 资源，这些资源中配置了该 Host cluster 管理的集群联邦中包含了哪些 member cluster。所有“联邦化”了的资源都会被部署到Host cluster中，并以相同的副本数复制部署到每一个 member cluster 中。控制平面的部署可以使用Helm chart。通过使用命令行工具kubefedctl，可以为联邦添加、删除集群，“联邦化”资源类型。根据 FeatrueGates 的具体配置，KubeFed 控制平面会相应启动多个 controller。</p><p>Host cluster 也可以作为 member cluster 加入联邦。</p><h2 id="Member-cluster"><a href="#Member-cluster" class="headerlink" title="Member cluster"></a>Member cluster</h2><p>集群联邦中的成员集群，用来部署“联邦化”的工作负载资源。</p><p>通过 KubeFed API 注册的集群，并提供相关身份凭证来让 KubeFed Controller 能够存取集群。</p><h2 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h2><p>定义跨级群通用资源的描述信息（representation）</p><h2 id="Placement"><a href="#Placement" class="headerlink" title="Placement"></a>Placement</h2><p>定义一个“联邦化”资源应该部署到哪些 member 集群中</p><h2 id="Overrides"><a href="#Overrides" class="headerlink" title="Overrides"></a>Overrides</h2><p>定义Template中，单机群的（per-cluster）、字段级别的变量（filed-level）</p><h2 id="Federated-Resources"><a href="#Federated-Resources" class="headerlink" title="Federated Resources"></a>Federated Resources</h2><p>被“联邦化”的资源</p><h2 id="Cluster-Configuration"><a href="#Cluster-Configuration" class="headerlink" title="Cluster Configuration"></a>Cluster Configuration</h2><p>用来定义哪些集群要被联邦。可以使用命令行工具 kubefedctl join/unjoin 来加入/删除集群。当集群成功加入联邦后，会建立一个 KubeFedCluster 组件来存储集群相关信息，如 API Endpoint、CA Bundle等。这些信息 KubeFed Controller 会用来管理 member 集群，以确保能够建立 Kubernetes API 资源</p><p>示意图如下所示：<br><img src="/2020/03/08/多集群资源统一管理之Federation-v2/sync-controller-1024x603.png" alt="2"></p><h2 id="KubeFed-API-Group"><a href="#KubeFed-API-Group" class="headerlink" title="KubeFed API Group"></a>KubeFed API Group</h2><p>KubeFed 通过 CRD 方式新增了4种 API 群组来实现联邦机制的核心功能：</p><table><thead><tr><th>API Group</th><th>用途</th></tr></thead><tbody><tr><td>core.kubefed.k8s.io</td><td>集群组态、联邦资源组态、KubeFed Controller 设定档等。</td></tr><tr><td>types.kubefed.k8s.io</td><td>被联邦的Kubernetes API 资源。</td></tr><tr><td>scheduling.kubefed.k8s.io</td><td>副本编排策略。</td></tr><tr><td>multiclusterdns.kubefed.k8s.io</td><td>跨集群服务发现设定。</td></tr></tbody></table><h2 id="Type-Configuration"><a href="#Type-Configuration" class="headerlink" title="Type Configuration"></a>Type Configuration</h2><p>用来定义哪些 Kubernetes API 资源要被联邦化。</p><p>举个例子，要将 ConfigMap 资源通过联邦机制建立在不同的集群上时，首先要在 Host 集群中通过 CRD 创建新资源 FederatedConfigMap，接着要创建名称为 configmaps 的 Type Configuration（FederatedTypeConfig）资源，描述 ConfigMap 要被 FederatedConfigMap 所管理。这样，KubeFed Controllers 才能知道如何创建 Federated ConfigMap 资源。</p><p>下面为范例：<br></p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="attr">apiVersion:</span> <span class="string">core.kubefed.k8s.io/v1beta1</span></div><div class="line"><span class="attr">kind:</span> <span class="string">FederatedTypeConfig</span></div><div class="line"><span class="attr">metadata:</span></div><div class="line"><span class="attr">  name:</span> <span class="string">configmaps</span></div><div class="line"><span class="attr">  namespace:</span> <span class="string">kube-federation-system</span></div><div class="line"><span class="attr">spec:</span></div><div class="line"><span class="attr">  federatedType:</span></div><div class="line"><span class="attr">    group:</span> <span class="string">types.kubefed.k8s.io</span></div><div class="line"><span class="attr">    kind:</span> <span class="string">FederatedConfigMap</span></div><div class="line"><span class="attr">    pluralName:</span> <span class="string">federatedconfigmaps</span></div><div class="line"><span class="attr">    scope:</span> <span class="string">Namespaced</span></div><div class="line"><span class="attr">    version:</span> <span class="string">v1beta1</span></div><div class="line"><span class="attr">  propagation:</span> <span class="string">Enabled</span></div><div class="line"><span class="attr">  targetType:</span></div><div class="line"><span class="attr">    kind:</span> <span class="string">ConfigMap</span></div><div class="line"><span class="attr">    pluralName:</span> <span class="string">configmaps</span></div><div class="line"><span class="attr">    scope:</span> <span class="string">Namespaced</span></div><div class="line"><span class="attr">    version:</span> <span class="string">v1</span></div></pre></td></tr></tbody></table></figure><p></p><p>也可以使用命令行工具新增 CRD 资源，kubefedctl enable <res>，举个例子：<br></res></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ kubefedctl <span class="built_in">enable</span> etcdclusters</div><div class="line">$ kubectl api-resources | grep etcd</div><div class="line">etcdclusters                      etcd         etcd.database.coreos.com         <span class="literal">true</span>         EtcdCluster</div><div class="line">federatedetcdclusters             fetcd        types.kubefed.k8s.io             <span class="literal">true</span>         FederatedEtcdCluster</div><div class="line"> </div><div class="line">$ kubectl -n kube-federation-system get federatedtypeconfigs | grep etcd</div><div class="line">etcdclusters.etcd.database.coreos.com    3m16s</div></pre></td></tr></tbody></table></figure><p></p><p>一个 federated 资源一般具备三个主要功能，这些功能信息能够在 spec 中由使用者自行定义，举个例子：<br></p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="attr">apiVersion:</span> <span class="string">types.kubefed.k8s.io/v1beta1</span></div><div class="line"><span class="attr">kind:</span> <span class="string">FederatedDeployment</span></div><div class="line"><span class="attr">metadata:</span></div><div class="line"><span class="attr">  name:</span> <span class="string">test-deployment</span></div><div class="line"><span class="attr">  namespace:</span> <span class="string">test-namespace</span></div><div class="line"><span class="attr">spec:</span></div><div class="line"><span class="attr">  template:</span> <span class="comment"># 定义 Deployment 的所有內容，可理解成 Deployment 与 Pod 之间的关联。</span></div><div class="line"><span class="attr">    metadata:</span></div><div class="line"><span class="attr">      labels:</span></div><div class="line"><span class="attr">        app:</span> <span class="string">nginx</span></div><div class="line"><span class="attr">    spec:</span></div><div class="line">      <span class="string">...</span></div><div class="line"><span class="attr">  placement:</span></div><div class="line"><span class="attr">    clusters:</span></div><div class="line"><span class="attr">    - name:</span> <span class="string">cluster2</span></div><div class="line"><span class="attr">    - name:</span> <span class="string">cluster1</span></div><div class="line"><span class="attr">  overrides:</span> </div><div class="line"><span class="attr">  - clusterName:</span> <span class="string">cluster2</span></div><div class="line"><span class="attr">    clusterOverrides:</span></div><div class="line"><span class="attr">    - path:</span> <span class="string">spec.replicas</span></div><div class="line"><span class="attr">      value:</span> <span class="number">5</span></div></pre></td></tr></tbody></table></figure><p></p><blockquote><ul><li>Template：定义 FederatedDeployment 的所有内容，类似普通 Deployment 的定义，比如 Deployment 与 Pod 之间的关联、副本数等等。</li><li>Placement：定义联邦化的 Deployment 资源发布到哪些集群中，如果没有定义该部分，则不会发布到任何集群。如果 placement 中定义了多个集群，这些集群中都会创建相同的 Deployment。另外也支持使用 spec.placement.clusterSelector 的方式来选择要放置的集群。</li><li>Override：用来修改制定集群中 Federated 资源的 spec.template 的内容。如例子 yaml 中使用 override 字段来修改 FederatedDeployment 在集群 cluster2 中的副本数为5。</li></ul></blockquote><h2 id="Scheduling"><a href="#Scheduling" class="headerlink" title="Scheduling"></a>Scheduling</h2><p>KubeFed 提供了一种自动化机制将工作负载实例分散的到不同的集群中，主要是基于资源的总副本数与集群的定义策略来将资源（Deployment或ReplicaSet）进行编排。</p><p>编排策略是通过建立 ReplicaSchedulingPreference（RSP）文件，再由 KubeFed RSP Controller 监听和获取 RSP 内容来将工作负载实例创建到指定的集群中。</p><p>举个 RSP 的例子，假设有三个集群被联邦管理，名称分别为 ap-northeast、us-east、us-west：<br></p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="attr">apiVersion:</span> <span class="string">scheduling.kubefed.k8s.io/v1alpha1</span></div><div class="line"><span class="attr">kind:</span> <span class="string">ReplicaSchedulingPreference</span></div><div class="line"><span class="attr">metadata:</span></div><div class="line"><span class="attr">  name:</span> <span class="string">test-deployment</span></div><div class="line"><span class="attr">  namespace:</span> <span class="string">test-ns</span></div><div class="line"><span class="attr">spec:</span></div><div class="line"><span class="attr">  targetKind:</span> <span class="string">FederatedDeployment</span></div><div class="line"><span class="attr">  totalReplicas:</span> <span class="number">15</span> </div><div class="line"><span class="attr">  clusters:</span> </div><div class="line">    <span class="string">"*"</span><span class="string">:</span></div><div class="line"><span class="attr">      weight:</span> <span class="number">2</span></div><div class="line"><span class="attr">      maxReplicas:</span> <span class="number">12</span></div><div class="line"><span class="attr">    ap-northeast:</span></div><div class="line"><span class="attr">      minReplicas:</span> <span class="number">1</span></div><div class="line"><span class="attr">      maxReplicas:</span> <span class="number">3</span></div><div class="line"><span class="attr">      weight:</span> <span class="number">1</span></div></pre></td></tr></tbody></table></figure><p></p><p>上面的 yaml 创建后，RSP Controller 监听并获取到资源，并匹配对应 namespace/name 下的 FederatedDeployment 与 FederatedReplicaSet 是否存在。若存在，会根据设定的策略计算出每个集群预期的副本数，之后覆写 Federated 资源中 spec.overrides 的内容以修改每个集群的副本数。最后由 KubeFed Sync Controller 来同步到每个集群的 Deployment。</p><p>以上面为例，结果为 ap-northeast 集群会拥有3个 Pod，us-east 和 us-weat 会分别拥有6个 Pod。<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">若spec.clusters未定义的话，则预设为{“*”:{Weight: 1}}。</div><div class="line"></div><div class="line">若有定义spec.replicas 的overrides 时，副本会以RSP 为优先考量。</div><div class="line"></div><div class="line">分配的计算机制可以参考kubefed/pkg/controller/util/planner/planner.go。</div></pre></td></tr></tbody></table></figure><p></p><p><img src="/2020/03/08/多集群资源统一管理之Federation-v2/rsp.png" alt="4"></p><h2 id="创建-Federated-资源"><a href="#创建-Federated-资源" class="headerlink" title="创建 Federated 资源"></a>创建 Federated 资源</h2><p>PushReconciler，其作用是自动将“联邦化”资源的变化推送到由 Placement 选择的 member cluster 中。举个例子，如果一个“联邦化”的资源，其在 member cluster 中的实际状态跟联邦资源中的期望状态不同时，比如副本数量因某种原因被删除了一个，pushreconciler会再次同步 member cluster 中该资源的实际状态与期望状态一致。</p><p>使用上面提到的 FederatedTypeConfig、KubeFedCluster、KubeFedConfig 三种配置文件，可以将任何类型的 Kubernetes 资源“联邦化”，包括用户自定义资源。</p><p>当“联邦化”一种 Kubernetes 资源后，会生成一个 FederatedTypeConfig 配置，该配置说明了 KubeFed 如何处理该种类型的资源。同时还会生成一个CRD，它描述了 Kubernetes API Server应该如何处理这种“联邦化”的资源。</p><p>下面看一个“联邦化”的例子，FederatedDeployment：<br></p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="attr">apiVersion:</span> <span class="string">types.kubefed.k8s.io/v1beta1</span></div><div class="line"><span class="attr">kind:</span> <span class="string">FederatedDeployment</span></div><div class="line"><span class="attr">metadata:</span></div><div class="line"><span class="attr">  name:</span> <span class="string">test-deployment</span></div><div class="line"><span class="attr">  namespace:</span> <span class="string">test</span></div><div class="line"><span class="attr">spec:</span></div><div class="line"><span class="attr">  template:</span></div><div class="line">    <span class="string"><<</span> <span class="string">DEPLOYMENT</span> <span class="string">SPEC</span> <span class="string">>></span></div><div class="line"><span class="attr">  placement:</span></div><div class="line"><span class="attr">    clusters:</span></div><div class="line"><span class="attr">    - name:</span> <span class="string">cluster2</span></div><div class="line"><span class="attr">    - name:</span> <span class="string">cluster1</span></div><div class="line"><span class="attr">    clusterSelector:</span></div><div class="line"><span class="attr">      matchLabels:</span></div><div class="line"><span class="attr">        region:</span> <span class="string">eu-west-1</span></div><div class="line"><span class="attr">  overrides:</span></div><div class="line"><span class="attr">  - clusterName:</span> <span class="string">cluster2</span></div><div class="line"><span class="attr">    clusterOverrides:</span></div><div class="line"><span class="attr">    - path:</span> <span class="string">spec.parallelism</span></div><div class="line"><span class="attr">      value:</span> <span class="number">2</span></div></pre></td></tr></tbody></table></figure><p></p><p>在 placement 段中，用户可以显示的以名称的方式制定 member cluster，也可以使用 clusterSelector 通过集群的 lable 指定。</p><p>在 overrides 段中，用户可以显示的使用 filed 变量名称，对于更复杂的描述信息可以使用json片段。</p><p>“联邦化”的资源是用 namespace 限定的，KubeFed可以配置为全局 scope 或者指定一个 namespace的。KubeFed 控制面会监听所配置的 namespace 中的联邦化资源。</p><p>如果设置的 scope 是 global，用户可以在任何 namespace 中创建联邦资源。</p><h2 id="Multi-Cluster-DNS（跨集群服务发现）"><a href="#Multi-Cluster-DNS（跨集群服务发现）" class="headerlink" title="Multi-Cluster DNS（跨集群服务发现）"></a>Multi-Cluster DNS（跨集群服务发现）</h2><p>这个 featrue 生效后，KubeFed 会 watch Service 和 Ingress 资源，将它们注册到外部 DNS服务器。</p><p>我们只要创建 Domain 资源，以及一个 ServiceDNSRecord（或者IngressDNSRecord，如果我们有 Ingress 资源的话）。</p><p>如下面yaml文件所示，创建 Domain 和 ServiceDNSRecord 资源，将 exampleDomain 和 exampleService 做关联：<br></p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attr">apiVersion:</span> <span class="string">multiclusterdns.kubefed.k8s.io/v1alpha1</span></div><div class="line"><span class="attr">kind:</span> <span class="string">Domain</span></div><div class="line"><span class="attr">metadata:</span></div><div class="line">  <span class="comment"># Corresponds to <federation> in the resource records.</span></div><div class="line"><span class="attr">  name:</span> <span class="string">exampleDomain</span></div><div class="line">  <span class="comment"># The namespace running the KubeFed control plane.</span></div><div class="line"><span class="attr">  namespace:</span> <span class="string">federation-system</span></div><div class="line"><span class="comment"># The domain/subdomain that is set up in your external-dns provider.</span></div><div class="line"><span class="attr">domain:</span> <span class="string">example.beta.banzaicloud.io</span></div></pre></td></tr></tbody></table></figure><p></p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="attr">apiVersion:</span> <span class="string">multiclusterdns.kubefed.k8s.io/v1alpha1</span></div><div class="line"><span class="attr">kind:</span> <span class="string">ServiceDNSRecord</span></div><div class="line"><span class="attr">metadata:</span></div><div class="line">  <span class="comment"># The name of the sample service.</span></div><div class="line"><span class="attr">  name:</span> <span class="string">exampleService</span></div><div class="line">  <span class="comment"># The namespace of the sample deployment/service.</span></div><div class="line"><span class="attr">  namespace:</span> <span class="string">test</span></div><div class="line"><span class="attr">spec:</span></div><div class="line">  <span class="comment"># The name of the corresponding `Domain`.</span></div><div class="line"><span class="attr">  domainRef:</span> <span class="string">exampleDomain</span></div><div class="line"><span class="attr">  recordTTL:</span> <span class="number">300</span></div></pre></td></tr></tbody></table></figure><p>一旦我们创建以上两种资源，KubeFed 就会创建一个 DNSEndpoint 对象，该对象中存有所有 DNS 名称及其所有 targets 。</p><p>首先假设已建立一个名称为nginx的FederatedDeployment，然后放到development namespace中，并且也建立了对应的FederatedService提供LoadBalancer。这时当建立上述Domain与ServiceDNSRecord后，KubeFed的Service DNS Controller会依据ServiceDNSRecord文件内容，去收集不同集群的Service信息，并将这些信息更新至ServiceDNSRecord状态中，接着DNS Endpoint Controller会依据该ServiceDNSRecord的状态内容，建立一个DNSEndpoint文件，并产生DNS records资源，最后再由ExternalDNS Controller来同步更新DNS records至DNS供应商。下图是Service DNS建立的架构。</p><p><img src="/2020/03/08/多集群资源统一管理之Federation-v2/service-dns.png" alt="5"></p><h2 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h2><p>KubeFed v2配置信息有两种</p><blockquote><ol><li>FederatedTypeConfig 用来指定哪些API类型 KubeFed 需要处理。</li><li>KubeFedCluster 和 KubeFedConfig 都是集群的配置项，用来指定哪些集群加入了 KubeFed 联邦管理。</li></ol></blockquote></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;Kubernetes Cluster Federation 又名 KubeFed 或 Federtation v2，是 Kubernetes SIG Multi-Cluster 团队新提出的集群联邦架构。新架构在 Federation v1 基础之上，简化扩展 Federated API过程，并加强跨集群服务发现与编排的功能。&lt;/p&gt;
&lt;p&gt;KubeFed 是Kubernetes官方多集群联邦解决方案。它允许用户使用在“Host cluster”中定义的一组简单的APIs，在多个Kubernetes集群中联合统一调度工作负载。&lt;/p&gt;
&lt;p&gt;KubeFed 与v1版本使用一套独立的Federation APIs不同，它创建和扩展了一套自定义资源。&lt;/p&gt;
&lt;p&gt;在 KubeFed 设计之初，有两个最重要的核心理念是其希望实现的，分别为 Modularization（模块化）和 Customizable（定制化）。这两个理念是希望 KubeFed 能够跟随着 Kubernetes 生态发展，并与之保持相容性和扩展性。&lt;/p&gt;
&lt;p&gt;与 v1 版本相比，KubeFed 最大的改变是将 API Server 移除，并通过 CRD 机制来完成 Federated Resources 的扩充，KubeFed Controller 负责管理这些 CRD，并实现同步 Resources 、跨集群编排等功能。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Kubernetes" scheme="https://www.flftuu.com/categories/Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>kubefed环境搭建</title>
    <link href="https://www.flftuu.com/2020/03/01/kubefed%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://www.flftuu.com/2020/03/01/kubefed环境搭建/</id>
    <published>2020-03-01T07:13:12.000Z</published>
    <updated>2020-05-06T07:30:17.349Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="kubefed客户端安装"><a href="#kubefed客户端安装" class="headerlink" title="kubefed客户端安装"></a>kubefed客户端安装</h1><p>下载地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2t1YmVybmV0ZXMtc2lncy9rdWJlZmVkL3JlbGVhc2VzL3RhZy92MC4yLjAtYWxwaGEuMQ==" title="https://github.com/kubernetes-sigs/kubefed/releases/tag/v0.2.0-alpha.1">https://github.com/kubernetes-sigs/kubefed/releases/tag/v0.2.0-alpha.1<i class="fa fa-external-link"></i></span><br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">curl -LO https://github.com/kubernetes-sigs/kubefed/releases/download/v0.2.0-alpha.1/kubefedctl-0.2.0-alpha.1-linux-amd64.tgz</div><div class="line">tar -zxvf kubefedctl-*.tgz</div><div class="line">chmod u+x kubefedctl</div><div class="line">sudo mv kubefedctl /usr/<span class="built_in">local</span>/bin/ <span class="comment"># make sure the location is in the PATH</span></div></pre></td></tr></tbody></table></figure><p></p><a id="more"></a><h1 id="使用helm安装kubefed控制面服务"><a href="#使用helm安装kubefed控制面服务" class="headerlink" title="使用helm安装kubefed控制面服务"></a>使用helm安装kubefed控制面服务</h1><blockquote><ol><li>下载并安装helm命令行</li><li>初始化：</li></ol></blockquote><p>helm init –client-only<br>因 <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLWNoYXJ0cy5zdG9yYWdlLmdvb2dsZWFwaXMuY29t" title="https://kubernetes-charts.storage.googleapis.com">https://kubernetes-charts.storage.googleapis.com<i class="fa fa-external-link"></i></span> 网络不通，需要手动创建$HOME/.helm/repository目录下把helm的repositories.yaml文件新建即可，参考wiki:Helm 基本使用</p><p>helm repo add kubefed-charts <span class="exturl" data-url="aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2t1YmVybmV0ZXMtc2lncy9rdWJlZmVkL21hc3Rlci9jaGFydHM=" title="https://raw.githubusercontent.com/kubernetes-sigs/kubefed/master/charts">https://raw.githubusercontent.com/kubernetes-sigs/kubefed/master/charts<i class="fa fa-external-link"></i></span></p><p>helm repo list 能看到已添加的库</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@vm192-168-0-203 cache]<span class="comment"># helm repo list</span></div><div class="line">NAME            URL</div><div class="line">stable          https://kubernetes-charts.storage.googleapis.com</div><div class="line">hub             https://hub.kce.ksyun.com/chartrepo/zhaoqi</div><div class="line">kubefed-charts  https://raw.githubusercontent.com/kubernetes-sigs/kubefed/master/charts</div></pre></td></tr></tbody></table></figure><p>helm search kubefed 查询kubefed chart包</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@vm192-168-0-203 cache]<span class="comment"># helm search kubefed</span></div><div class="line">WARNING: Repo <span class="string">"stable"</span> is corrupt or missing. Try <span class="string">'helm repo update'</span>.</div><div class="line">NAME                            CHART VERSION   APP VERSION DESCRIPTION</div><div class="line">kubefed-charts/kubefed          0.2.0-alpha.1               KubeFed helm chart</div><div class="line">kubefed-charts/federation-v2    0.0.10                      Kubernetes Federation V2 helm chart</div></pre></td></tr></tbody></table></figure><p>helm install kubefed-charts/kubefed –name kubefed –version 0.2.0-alpha.1 –namespace kube-federation-system<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">[root@vm192-168-0-203 cache]<span class="comment"># kubectl get crd | grep kubefed</span></div><div class="line">clusterpropagatedversions.core.kubefed.io            2020-04-27T09:05:34Z</div><div class="line">dnsendpoints.multiclusterdns.kubefed.io              2020-04-27T09:05:34Z</div><div class="line">domains.multiclusterdns.kubefed.io                   2020-04-27T09:05:34Z</div><div class="line">federatedclusterroles.types.kubefed.io               2020-04-27T09:05:34Z</div><div class="line">federatedconfigmaps.types.kubefed.io                 2020-04-27T09:05:34Z</div><div class="line">federateddeployments.types.kubefed.io                2020-04-27T09:05:34Z</div><div class="line">federatedingresses.types.kubefed.io                  2020-04-27T09:05:34Z</div><div class="line">federatedjobs.types.kubefed.io                       2020-04-27T09:05:34Z</div><div class="line">federatednamespaces.types.kubefed.io                 2020-04-27T09:05:34Z</div><div class="line">federatedreplicasets.types.kubefed.io                2020-04-27T09:05:34Z</div><div class="line">federatedsecrets.types.kubefed.io                    2020-04-27T09:05:34Z</div><div class="line">federatedserviceaccounts.types.kubefed.io            2020-04-27T09:05:34Z</div><div class="line">federatedservices.types.kubefed.io                   2020-04-27T09:05:34Z</div><div class="line">federatedservicestatuses.core.kubefed.io             2020-04-27T09:05:34Z</div><div class="line">federatedtypeconfigs.core.kubefed.io                 2020-04-27T09:05:34Z</div><div class="line">ingressdnsrecords.multiclusterdns.kubefed.io         2020-04-27T09:05:34Z</div><div class="line">kubefedclusters.core.kubefed.io                      2020-04-27T09:05:34Z</div><div class="line">kubefedconfigs.core.kubefed.io                       2020-04-27T09:05:34Z</div><div class="line">propagatedversions.core.kubefed.io                   2020-04-27T09:05:34Z</div><div class="line">replicaschedulingpreferences.scheduling.kubefed.io   2020-04-27T09:05:34Z</div><div class="line">servicednsrecords.multiclusterdns.kubefed.io         2020-04-27T09:05:34Z</div><div class="line"></div><div class="line">[root@vm192-168-0-203 cache]<span class="comment"># kubectl get deploy -n kube-federation-system</span></div><div class="line">NAME                         READY   UP-TO-DATE   AVAILABLE   AGE</div><div class="line">kubefed-admission-webhook    1/1     1            1           69m</div><div class="line">kubefed-controller-manager   2/2     2            2           69m</div></pre></td></tr></tbody></table></figure><p></p><p>将两个集群加入联邦<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@vm192-168-0-203 ~]<span class="comment"># kubefedctl join --cluster-context context-1580a941-b081-4663-a998-4426ea561192 cluster1 --host-cluster-context context-1580a941-b081-4663-a998-4426ea561192</span></div><div class="line">[root@vm192-168-0-203 ~]<span class="comment"># kubefedctl join --cluster-context context-1580a941-b081-4663-a998-4426ea561192 cluster2 --host-cluster-context context-1580a941-b081-4663-a998-4426ea561192</span></div><div class="line">[root@vm192-168-0-203 ~]<span class="comment"># kubectl get kubefedcluster -n kube-federation-system</span></div><div class="line">NAME       AGE   READY</div><div class="line">cluster1   4h    True</div><div class="line">cluster2   1s    True</div></pre></td></tr></tbody></table></figure><p></p><p>联邦化的资源类型<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[root@vm192-168-0-203 kubefed]<span class="comment"># kubectl get FederatedTypeConfig -n kube-federation-system</span></div><div class="line">NAME                                             AGE</div><div class="line">clusterroles.rbac.authorization.k8s.io           1d</div><div class="line">configmaps                                       1d</div><div class="line">customresourcedefinitions.apiextensions.k8s.io   5h</div><div class="line">deployments.apps                                 1d</div><div class="line">ingresses.extensions                             1d</div><div class="line">jobs.batch                                       3h</div><div class="line">namespaces                                       1d</div><div class="line">replicasets.apps                                 1d</div><div class="line">secrets                                          1d</div><div class="line">serviceaccounts                                  1d</div><div class="line">services                                         1d</div></pre></td></tr></tbody></table></figure><p></p><p>可以使用kubefedctl disable / enable 联邦化某种资源，包括crd资源类型<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[root@vm192-168-0-203 kubefed]<span class="comment"># kubefedctl disable job</span></div><div class="line">Disabled propagation <span class="keyword">for</span> FederatedTypeConfig <span class="string">"kube-federation-system/jobs.batch"</span></div><div class="line">Verifying propagation controller is stopped <span class="keyword">for</span> FederatedTypeConfig <span class="string">"kube-federation-system/jobs.batch"</span></div><div class="line">Propagation controller <span class="keyword">for</span> FederatedTypeConfig <span class="string">"kube-federation-system/jobs.batch"</span> is stopped</div><div class="line">federatedtypeconfig <span class="string">"kube-federation-system/jobs.batch"</span> deleted</div><div class="line"> </div><div class="line"> </div><div class="line">[root@vm192-168-0-203 kubefed]<span class="comment"># kubefedctl enable job</span></div><div class="line">customresourcedefinition.apiextensions.k8s.io/federatedjobs.types.kubefed.io updated</div><div class="line">federatedtypeconfig.core.kubefed.io/jobs.batch created <span class="keyword">in</span> namespace kube-federation-system</div></pre></td></tr></tbody></table></figure><p></p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;kubefed客户端安装&quot;&gt;&lt;a href=&quot;#kubefed客户端安装&quot; class=&quot;headerlink&quot; title=&quot;kubefed客户端安装&quot;&gt;&lt;/a&gt;kubefed客户端安装&lt;/h1&gt;&lt;p&gt;下载地址：&lt;a href=&quot;https://github.com/kubernetes-sigs/kubefed/releases/tag/v0.2.0-alpha.1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/kubernetes-sigs/kubefed/releases/tag/v0.2.0-alpha.1&lt;/a&gt;&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;curl -LO https://github.com/kubernetes-sigs/kubefed/releases/download/v0.2.0-alpha.1/kubefedctl-0.2.0-alpha.1-linux-amd64.tgz&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;tar -zxvf kubefedctl-*.tgz&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;chmod u+x kubefedctl&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;sudo mv kubefedctl /usr/&lt;span class=&quot;built_in&quot;&gt;local&lt;/span&gt;/bin/ &lt;span class=&quot;comment&quot;&gt;# make sure the location is in the PATH&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Kubernetes" scheme="https://www.flftuu.com/categories/Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>golang依赖管理</title>
    <link href="https://www.flftuu.com/2020/02/26/golang%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"/>
    <id>https://www.flftuu.com/2020/02/26/golang依赖管理/</id>
    <published>2020-02-26T06:51:08.000Z</published>
    <updated>2020-05-06T07:30:47.453Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="govendor-缺点"><a href="#govendor-缺点" class="headerlink" title="govendor 缺点"></a>govendor 缺点</h2><p>govendor依赖管理太松散，同一个依赖项目，不同的组件引用，版本可以不一样，例如vendor.json：</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">{</div><div class="line">     <span class="attr">"checksumSHA1"</span>: <span class="string">"ehAUZgg3BT4gz3WA5B9l2o4NOHw="</span>,</div><div class="line">     <span class="attr">"path"</span>: <span class="string">"k8s.io/apimachinery/pkg/api/equality"</span>,</div><div class="line">     <span class="attr">"revision"</span>: <span class="string">"035e418f1ad9b6da47c4e01906a0cfe32f4ee2e7"</span>,</div><div class="line">     <span class="attr">"revisionTime"</span>: <span class="string">"2019-07-31T12:28:47Z"</span></div><div class="line">},</div><div class="line">{</div><div class="line">      <span class="attr">"checksumSHA1"</span>: <span class="string">"bmva3UAPnGM9sI9Ap5hXRhlH4wA="</span>,</div><div class="line">      <span class="attr">"path"</span>: <span class="string">"k8s.io/apimachinery/pkg/api/errors"</span>,</div><div class="line">      <span class="attr">"revision"</span>: <span class="string">"1f8faeb8119141131b81637c896fc4c30e7075ae"</span>,</div><div class="line">      <span class="attr">"revisionTime"</span>: <span class="string">"2019-07-30T15:53:30Z"</span></div><div class="line">},</div></pre></td></tr></tbody></table></figure><a id="more"></a><p>这样，当有其他依赖如 k8s.io/client-go，也依赖 k8s.io/apimachinery 的不通版本时，会造成依赖冲突</p><h2 id="go-mod-优点"><a href="#go-mod-优点" class="headerlink" title="go mod 优点"></a>go mod 优点</h2><blockquote><ul><li>官方推出的依赖管理工具</li><li>可以摆脱GOPATH</li><li>可以通过代理下载墙外依赖</li></ul></blockquote><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><blockquote><ol><li>golang 升级到 1.13</li><li>设置环境变量：<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">GOPROXY=https://goproxy.cn</div><div class="line">GOPRIVATE=*.flftuu.com</div><div class="line">GONOPROXY=*.flftuu.com</div><div class="line">GONOSUMDB=*.flftuu.com</div><div class="line">GO111MODULE=auto</div></pre></td></tr></tbody></table></figure></li></ol></blockquote><h1 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h1><blockquote><ol><li>newgit上新建项目，例如：newgit.op.flftuu.com/my/my_project</li><li>本地新建项目根目录，并初始化 go mod    <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ mkdir my_project </div><div class="line">$ <span class="built_in">cd</span> my_project</div><div class="line">$ go mod init newgit.op.flftuu.com/my/my_project</div></pre></td></tr></tbody></table></figure></li></ol></blockquote><blockquote><ol start="3"><li>写完代码后，更新依赖并保存到vendor目录<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ go mod tidy</div><div class="line">$ go mod vendor</div></pre></td></tr></tbody></table></figure></li></ol></blockquote><blockquote><ol start="4"><li>git 提交代码</li></ol></blockquote><h2 id="从-govendor-改造"><a href="#从-govendor-改造" class="headerlink" title="从 govendor 改造"></a>从 govendor 改造</h2><blockquote><ol><li>下载项目，并删除vendor目录</li><li>初始化 go mod<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> my_project</div><div class="line">$ go mod init newgit.op.flftuu.com/my/my_project</div><div class="line">$ go mod tidy</div></pre></td></tr></tbody></table></figure></li></ol></blockquote><blockquote><ol start="3"><li>添加依赖<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ go get k8s.io/api@kubernetes-1.14.0</div><div class="line">$ go get -v -insecure newgit.op.flftuu.com/kce/appclient@develop  <span class="comment">#添加非 https 服务的依赖，需要将 git 账号密码保存到 windows ，否则拉取会失败</span></div></pre></td></tr></tbody></table></figure></li></ol></blockquote><blockquote><ol start="4"><li>保存依赖到vendor<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go mod vendor</div></pre></td></tr></tbody></table></figure></li></ol></blockquote><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><blockquote><ol><li>使用go mod管理的依赖，执行 go get 时需要指定版本，例如：<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">以分支为版本：go get k8s.io/api@master</div><div class="line">以 tag 为版本：go get k8s.io/api@kubernetes-1.14.0</div><div class="line">以 commit 为版本: go get k8s.io/api@40a48860b5abbba9aa891b02b32da429b08d96a0</div></pre></td></tr></tbody></table></figure></li></ol></blockquote><blockquote><ol start="2"><li>由于 client-go 对 kubernetes 项目兼容性不足，需要使用client-go对应的kubernetes相关依赖版本，详见 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2t1YmVybmV0ZXMvY2xpZW50LWdvI2NvbXBhdGliaWxpdHktbWF0cml4" title="https://github.com/kubernetes/client-go#compatibility-matrix">https://github.com/kubernetes/client-go#compatibility-matrix<i class="fa fa-external-link"></i></span></li><li>本次改动，基于 kubernetes 的版本全部为 1.14 ，例如：<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">k8s.io/apimachinery@kubernetes-1.14.0</div><div class="line">k8s.io/client-go@v11.0.0    </div><div class="line">k8s.io/api@kubernetes-1.14.0</div><div class="line">k8s.io/apiextensions-apiserver@kubernetes-1.14.0</div><div class="line">k8s.io/apiserver@kubernetes-1.14.0</div><div class="line">k8s.io/component-base@kubernetes-1.14.0</div><div class="line">k8s.io/apiextensions-apiserver@v0.0.0-20190315093550-53c4693659ed</div><div class="line">k8s.io/api</div></pre></td></tr></tbody></table></figure></li></ol></blockquote></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;h2 id=&quot;govendor-缺点&quot;&gt;&lt;a href=&quot;#govendor-缺点&quot; class=&quot;headerlink&quot; title=&quot;govendor 缺点&quot;&gt;&lt;/a&gt;govendor 缺点&lt;/h2&gt;&lt;p&gt;govendor依赖管理太松散，同一个依赖项目，不同的组件引用，版本可以不一样，例如vendor.json：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;span class=&quot;attr&quot;&gt;&quot;checksumSHA1&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;ehAUZgg3BT4gz3WA5B9l2o4NOHw=&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;span class=&quot;attr&quot;&gt;&quot;path&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;k8s.io/apimachinery/pkg/api/equality&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;span class=&quot;attr&quot;&gt;&quot;revision&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;035e418f1ad9b6da47c4e01906a0cfe32f4ee2e7&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;span class=&quot;attr&quot;&gt;&quot;revisionTime&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;2019-07-31T12:28:47Z&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;attr&quot;&gt;&quot;checksumSHA1&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;bmva3UAPnGM9sI9Ap5hXRhlH4wA=&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;attr&quot;&gt;&quot;path&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;k8s.io/apimachinery/pkg/api/errors&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;attr&quot;&gt;&quot;revision&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;1f8faeb8119141131b81637c896fc4c30e7075ae&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;attr&quot;&gt;&quot;revisionTime&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;2019-07-30T15:53:30Z&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;,&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Kubernetes" scheme="https://www.flftuu.com/categories/Kubernetes/"/>
    
    
      <category term="go" scheme="https://www.flftuu.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客同时部署到github和VPS上</title>
    <link href="https://www.flftuu.com/2020/02/18/hexo%E5%8D%9A%E5%AE%A2%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2%E5%88%B0github%E5%92%8CVPS%E4%B8%8A/"/>
    <id>https://www.flftuu.com/2020/02/18/hexo博客同时部署到github和VPS上/</id>
    <published>2020-02-18T03:41:44.000Z</published>
    <updated>2020-04-28T03:53:50.863Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有一台VPS一直空闲，未免有点浪费，所以想把博客部署到VPS上，并且绑定域名</p><p>之前尝试过这么做过，但是一直都没有成功，因为这其中有很多细节都是需要注意的，所以还是写一篇博客来记录这次的部署过程</p><p>以后换VPS的时候就不用像这次一样到处查找资料了</p><a id="more"></a><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>部署到VPS的原理即是在VPS上搭建git服务器，然后每次提交public文件夹中的文件到VPS时，通过git-hooks钩子来同时复制文件到网站的根目录上</p><p>其实关键的是git服务器的搭建，因为想要免密码ssh登录的话需要配置一系列东西</p><p>部署到github就不说了，因为这个非常好部署，github其实也是一个git服务器，但是其已经搭建好了，我们只需要将公钥交给github即可完成免密码登录</p><h1 id="git服务器的搭建"><a href="#git服务器的搭建" class="headerlink" title="git服务器的搭建"></a>git服务器的搭建</h1><h2 id="安装git并配置用户与邮箱"><a href="#安装git并配置用户与邮箱" class="headerlink" title="安装git并配置用户与邮箱"></a>安装git并配置用户与邮箱</h2><p>首先创建好git用户并且输入密码</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ useradd git</div></pre></td></tr></tbody></table></figure><p>随后就是配置git的用户名和邮箱<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name <span class="string">"username"</span>  </div><div class="line">$ git config --global user.email <span class="string">"mail@gmail.com"</span></div></pre></td></tr></tbody></table></figure><p></p><p>配置完成后生成SSH密钥<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen -t rsa -C <span class="string">"mail@gmail.com"</span></div></pre></td></tr></tbody></table></figure><p></p><p>我们选择保存在 /home/git/.ssh/id_rsa中，以后这个文件夹还是有用的</p><h2 id="添加公钥"><a href="#添加公钥" class="headerlink" title="添加公钥"></a>添加公钥</h2><p>新建一个名为authorized_keys的文件，并将公钥复制进去</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim .ssh/authorized_keys</div></pre></td></tr></tbody></table></figure><p>随后打开RSA认证</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim /etc/ssh/sshd_config</div></pre></td></tr></tbody></table></figure><p>找到下面这一行，修改为</p><p>AuthorizedKeysFile .ssh/authorized_keys</p><p>这样公钥就已经配置好了</p><h2 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h2><p>修改权限这一步是非常重要的，我之前的原因应该就是卡在这一步，所以无法达到免密码ssh登录</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ chmod 700 .ssh </div><div class="line">$ chmod 600 .ssh/authorized_keys</div><div class="line">$ <span class="built_in">cd</span> /home</div><div class="line">$ chown -R git:git git</div></pre></td></tr></tbody></table></figure><p>关闭git的shell登录<br>为了安全起见，我们拒绝git的shell权限</p><p>修改下面文件内容</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ vim /etc/passwd</div><div class="line">将</div><div class="line"></div><div class="line">git:x:1001:1001:,,,:/home/git:/bin/bash</div><div class="line">改成</div><div class="line"></div><div class="line">git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</div></pre></td></tr></tbody></table></figure><p>Nginx的配置与Githooks的脚本实现<br>Nginx配置文件<br>修改配置文件前先备份</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> /etc/nginx/sites-available    </div><div class="line">$ cp default default.bak     </div><div class="line">$ vim default</div></pre></td></tr></tbody></table></figure><p>然后在文件中输入下面配置内容<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">server {</div><div class="line">        listen 80 default;</div><div class="line">        root /var/www/blog;</div><div class="line">        index index.html index.htm index.nginx-debian.html;</div><div class="line">        server_name vhyz.me www.vhyz.me;</div><div class="line">        location / {</div><div class="line">                <span class="comment"># First attempt to serve request as file, then</span></div><div class="line">                <span class="comment"># as directory, then fall back to displaying a 404.</span></div><div class="line">                try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ =404;</div><div class="line">        }</div><div class="line">        location ~* ^.+\.(css|js|txt|xml|swf|wav)$ {</div><div class="line">                root /var/www/blog;</div><div class="line">                access_log   off;</div><div class="line">                expires      10m;</div><div class="line">        }</div><div class="line">        location ~* ^.+\.(ico|gif|jpg|jpeg|png)$ {</div><div class="line">                root /var/www/blog;</div><div class="line">                access_log   off;</div><div class="line">                expires      1d;</div><div class="line">        }</div><div class="line">}</div></pre></td></tr></tbody></table></figure><p></p><p>修改完保存，重启nginx</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo service nginx restart</div></pre></td></tr></tbody></table></figure><p>新建blog.git<br>新建blog.git裸仓库与网站根目录<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> /home/git</div><div class="line">$ git init --bare blog.git</div><div class="line">$ <span class="built_in">cd</span> /var/www</div><div class="line">$ mkdir blog</div></pre></td></tr></tbody></table></figure><p></p><p>然后修改用户组权限<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ chown git:git -R /var/www/blog</div><div class="line">$ chown git:git -R /home/git/blog.git</div></pre></td></tr></tbody></table></figure><p></p><p>记住每个仓库都需要这样设置权限</p><p>配置Git Hooks<br>新建post-receive文件<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> /home/git/blog.git/hooks  </div><div class="line">$ vim post-receive </div><div class="line">```  </div><div class="line">然后输入下面脚本内容</div><div class="line">```bash</div><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"> GIT_REPO=/home/git/blog.git</div><div class="line"> TMP_GIT_CLONE=/tmp/blog</div><div class="line"> PUBLIC_WWW=/var/www/blog</div><div class="line"> rm -rf <span class="variable">${TMP_GIT_CLONE}</span></div><div class="line"> git <span class="built_in">clone</span> <span class="variable">$GIT_REPO</span> <span class="variable">$TMP_GIT_CLONE</span></div><div class="line"> rm -rf <span class="variable">${PUBLIC_WWW}</span>/*</div><div class="line"> cp -rf <span class="variable">${TMP_GIT_CLONE}</span>/* <span class="variable">${PUBLIC_WWW}</span></div></pre></td></tr></tbody></table></figure><p></p><p>保存完之后赋予可执行权限<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ chmod +x post-receive</div></pre></td></tr></tbody></table></figure><p></p><h2 id="hexo本地配置"><a href="#hexo本地配置" class="headerlink" title="hexo本地配置"></a>hexo本地配置</h2><p>在站点配置文件中deploy修改为下面内容,your_ip代表了服务器的地址</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attr">deploy:</span></div><div class="line"><span class="attr">-   type:</span> <span class="string">git</span></div><div class="line"><span class="attr">    repo:</span> <span class="attr">https://github.com/vhyz/vhyz.github.io</span></div><div class="line"><span class="attr">    branch:</span> <span class="string">master</span>                            </div><div class="line"><span class="attr">    message:</span>                                  </div><div class="line"><span class="attr">-   type:</span> <span class="string">git</span></div><div class="line"><span class="attr">    repo:</span> <span class="string">git@your_ip:blog.git</span></div><div class="line"><span class="attr">    branch:</span> <span class="string">master</span>                            </div><div class="line"><span class="attr">    message:</span></div></pre></td></tr></tbody></table></figure><p>如果服务器端口不是默认22，则需要在本地的.ssh文件夹中创建config配置文件</p><p>输入下面内容<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Host </div><div class="line">HostName </div><div class="line">User git</div><div class="line">Port </div><div class="line">IdentityFile ~/.ssh/id_rsa</div></pre></td></tr></tbody></table></figure><p></p><p>Host与HostName均为你的服务器IP地址</p><p>然后输入<br></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo g -d</div></pre></td></tr></tbody></table></figure><p></p><p>即可完成一次对两个服务器的部署</p><p><span class="exturl" data-url="aHR0cHM6Ly92aHl6Lm1lLzIwMTgvMDYvMDkvaGV4byVFNSU4RCU5QSVFNSVBRSVBMiVFNSU5MCU4QyVFNiU5NyVCNiVFOSU4MyVBOCVFNyVCRCVCMiVFNSU4OCVCMGdpdGh1YiVFNSU5MiU4Q1ZQUyVFNCVCOCU4QS9pbmRleC5odG1s" title="https://vhyz.me/2018/06/09/hexo%E5%8D%9A%E5%AE%A2%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2%E5%88%B0github%E5%92%8CVPS%E4%B8%8A/index.html">转载自<i class="fa fa-external-link"></i></span></p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;有一台VPS一直空闲，未免有点浪费，所以想把博客部署到VPS上，并且绑定域名&lt;/p&gt;
&lt;p&gt;之前尝试过这么做过，但是一直都没有成功，因为这其中有很多细节都是需要注意的，所以还是写一篇博客来记录这次的部署过程&lt;/p&gt;
&lt;p&gt;以后换VPS的时候就不用像这次一样到处查找资料了&lt;/p&gt;
    
    </summary>
    
      <category term="Kubernetes" scheme="https://www.flftuu.com/categories/Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>coredns解析集群node节点</title>
    <link href="https://www.flftuu.com/2020/02/02/coredns%E8%A7%A3%E6%9E%90%E9%9B%86%E7%BE%A4node%E8%8A%82%E7%82%B9/"/>
    <id>https://www.flftuu.com/2020/02/02/coredns解析集群node节点/</id>
    <published>2020-02-02T02:40:57.000Z</published>
    <updated>2020-04-28T03:38:41.946Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="k8s-node"><a href="#k8s-node" class="headerlink" title="k8s_node"></a>k8s_node</h1><h2 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h2><p><em>k8s_node</em> - resolves node hostname and node IPs from Kubernetes clusters.</p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>This plugin resolves node external IP and internal IP address(es) of Kubernetes clusters.<br>This plugin is only useful if the <em>kubernetes</em> plugin is also loaded.</p><p>The plugin resolve node IP addresses. It only handles queries for A and AAAA records;<br>all others result in NODATA responses.</p><a id="more"></a><h2 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">k8s_node</div></pre></td></tr></tbody></table></figure><p>If you want to change the apex domain or use a different TTL for the returned records you can use<br>this extended syntax.</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">k8s_node {</div><div class="line">    ttl TTL</div><div class="line">}</div></pre></td></tr></tbody></table></figure><ul><li><code>ttl</code> allows you to set a custom <strong>TTL</strong> for responses. The default is 5 (seconds).</li></ul><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">. {</div><div class="line">   kubernetes cluster.local</div><div class="line">   k8s_node</div><div class="line">}</div></pre></td></tr></tbody></table></figure><p>With the Corefile above, the following Service will get an <code>A</code> record for <code>vm10-0-10-80.ksc.com</code> with the IP address <code>10.0.10.80</code>.</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">status:</div><div class="line">  addresses:</div><div class="line">  - address: 10.0.10.80</div><div class="line">    type: InternalIP</div><div class="line">  - address: vm10-0-10-80.ksc.com</div><div class="line">    type: Hostname</div></pre></td></tr></tbody></table></figure><h1 id="Bugs"><a href="#Bugs" class="headerlink" title="Bugs"></a>Bugs</h1><p>PTR queries for the reverse zone is not supported.</p><h1 id="Also-See"><a href="#Also-See" class="headerlink" title="Also See"></a>Also See</h1><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tjZS1kZXYvY29yZWRucw==" title="https://github.com/kce-dev/coredns">source code<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9yZXBvc2l0b3J5L2RvY2tlci9mbGZ0dXUvY29yZWRucw==" title="https://hub.docker.com/repository/docker/flftuu/coredns">docker image<i class="fa fa-external-link"></i></span></p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;k8s-node&quot;&gt;&lt;a href=&quot;#k8s-node&quot; class=&quot;headerlink&quot; title=&quot;k8s_node&quot;&gt;&lt;/a&gt;k8s_node&lt;/h1&gt;&lt;h2 id=&quot;Name&quot;&gt;&lt;a href=&quot;#Name&quot; class=&quot;headerlink&quot; title=&quot;Name&quot;&gt;&lt;/a&gt;Name&lt;/h2&gt;&lt;p&gt;&lt;em&gt;k8s_node&lt;/em&gt; - resolves node hostname and node IPs from Kubernetes clusters.&lt;/p&gt;
&lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;p&gt;This plugin resolves node external IP and internal IP address(es) of Kubernetes clusters.&lt;br&gt;This plugin is only useful if the &lt;em&gt;kubernetes&lt;/em&gt; plugin is also loaded.&lt;/p&gt;
&lt;p&gt;The plugin resolve node IP addresses. It only handles queries for A and AAAA records;&lt;br&gt;all others result in NODATA responses.&lt;/p&gt;
    
    </summary>
    
      <category term="Kubernetes" scheme="https://www.flftuu.com/categories/Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>kubemark测试k8s集群</title>
    <link href="https://www.flftuu.com/2020/01/07/kubemark%E6%B5%8B%E8%AF%95k8s%E9%9B%86%E7%BE%A4/"/>
    <id>https://www.flftuu.com/2020/01/07/kubemark测试k8s集群/</id>
    <published>2020-01-07T07:38:42.000Z</published>
    <updated>2020-01-08T10:01:00.308Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="搭建-kubemark-流程"><a href="#搭建-kubemark-流程" class="headerlink" title="搭建 kubemark 流程"></a>搭建 kubemark 流程</h2><p>由于官方搭建的 kubemark 集群依赖比较多且不是特别符合我们的场景，所以以下针对金上云的集群环境搭建测试集群。</p><p>先使用金山云平台搭建两个真实的集群。集群规格是 3 master(2c4g), 2 node(32c64g)，一个作为 kubemark 集群， 另一个用来部署 hollow-node pod，称为 support 集群。</p><p>配置本地 kubectl 连接到support集群。</p><p>在support集群创建如下资源</p><h2 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h2><p>测试集群：<br>    master个数： 3<br>    master规格： 1c2g ~ 2c4g<br>    node： 使用kubemark模拟</p><a id="more"></a><p>一共测试了以下10个case：</p><blockquote><ol><li>50 node</li><li>100 node</li><li>150 node</li><li>200 node</li><li>250 node</li><li>300 node</li><li>350 node</li><li>400 node</li><li>450 node</li><li>500 node</li></ol></blockquote></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;搭建-kubemark-流程&quot;&gt;&lt;a href=&quot;#搭建-kubemark-流程&quot; class=&quot;headerlink&quot; title=&quot;搭建 kubemark 流程&quot;&gt;&lt;/a&gt;搭建 kubemark 流程&lt;/h2&gt;&lt;p&gt;由于官方搭建的 kubemark 集群依赖比较多且不是特别符合我们的场景，所以以下针对金上云的集群环境搭建测试集群。&lt;/p&gt;
&lt;p&gt;先使用金山云平台搭建两个真实的集群。集群规格是 3 master(2c4g), 2 node(32c64g)，一个作为 kubemark 集群， 另一个用来部署 hollow-node pod，称为 support 集群。&lt;/p&gt;
&lt;p&gt;配置本地 kubectl 连接到support集群。&lt;/p&gt;
&lt;p&gt;在support集群创建如下资源&lt;/p&gt;
&lt;h2 id=&quot;集群配置&quot;&gt;&lt;a href=&quot;#集群配置&quot; class=&quot;headerlink&quot; title=&quot;集群配置&quot;&gt;&lt;/a&gt;集群配置&lt;/h2&gt;&lt;p&gt;测试集群：&lt;br&gt;    master个数： 3&lt;br&gt;    master规格： 1c2g ~ 2c4g&lt;br&gt;    node： 使用kubemark模拟&lt;/p&gt;
    
    </summary>
    
      <category term="Kubernetes" scheme="https://www.flftuu.com/categories/Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>etcd性能测试</title>
    <link href="https://www.flftuu.com/2019/12/27/etcd%E6%80%A7%E8%83%BD/"/>
    <id>https://www.flftuu.com/2019/12/27/etcd性能/</id>
    <published>2019-12-27T06:13:34.000Z</published>
    <updated>2020-01-07T06:56:03.016Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="理解性能"><a href="#理解性能" class="headerlink" title="理解性能"></a>理解性能</h2><p>决定 etcd 性能的关键因素，包括：</p><blockquote><ol><li>延迟(latency)：延迟是完成操作的时间。</li><li>吞吐量(throughput)：吞吐量是在某个时间期间之内完成操作的总数量。 当 etcd 接收并发客户端请求时，通常平均延迟随着总体吞吐量增加而增加。</li></ol></blockquote><a id="more"></a><p>etcd 使用 Raft 一致性算法来在成员之间复制请求并达成一致。</p><p>一致性性能，特别是提交延迟，受限于两个物理约束：</p><blockquote><ol><li>网络IO延迟</li><li>磁盘IO延迟</li></ol></blockquote><p>完成一个 etcd 请求的最小时间是成员之间的网络往返时延(Round Trip Time / RTT)，加需要提交数据到持久化存储的 fdatasync 时间。</p><blockquote><ol><li>在一个数据中心内的 RTT 可能有数百毫秒。</li></ol></blockquote><p>机械硬盘的典型 fdatasync 延迟是大概 10ms。对于 SSD 硬盘, 延迟通常低于 1ms。</p><p>为了提高吞吐量, etcd 将多个请求打包在一起并提交给 Raft。</p><blockquote><ol><li>这个批量策略让 etcd 在重负载试获得高吞吐量。</li></ol></blockquote><p>有其他子系统影响到 etcd 的整体性能。</p><blockquote><ol><li>每个序列化的 etcd 请求必须通过 etcd 的 boltdb支持的(boltdb-backed) MVCC 存储引擎,它通常需要10微秒来完成。</li></ol></blockquote><p>etcd 定期递增快照它最近实施的请求，将他们和之前在磁盘上的快照合并。这个过程可能导致延迟尖峰(latency spike)。</p><blockquote><ol><li>虽然在SSD上这通常不是问题，在HDD上它可能加倍可观察到的延迟。</li></ol></blockquote><p>进行中的压缩可以影响 etcd 的性能。</p><blockquote><ol><li>幸运的是，压缩通常无足轻重，因为压缩是错开的，因此它不和常规请求竞争资源。</li></ol></blockquote><p>RPC 系统，gRPC，为 etcd 提供定义良好，可扩展的 API。</p><blockquote><ol><li>但是它也引入了额外的延迟，尤其是本地读取。</li></ol></blockquote><h2 id="评测性能"><a href="#评测性能" class="headerlink" title="评测性能"></a>评测性能</h2><p>可以通过 etcd 自带的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvcmVvcy9ldGNkL3RyZWUvbWFzdGVyL3Rvb2xzL2JlbmNobWFyaw==" title="https://github.com/coreos/etcd/tree/master/tools/benchmark">benchmark<i class="fa fa-external-link"></i></span> CLI 工具来评测 etcd 的性能。</p><p>对于某些基线性能数字，考虑搭建3节点 etcd 集群，带有下列硬件配置：</p><blockquote><ol><li>搭建 etcd 集群：3 副本etcd pod， 1 vCPUs + 2GB Memory + ssd磁盘（每个机器都有不少进程在上面）</li><li>评测 etcd 节点：1 台机器(客户端)，16 vCPUs + 32GB Memory + 普通磁盘，用于做benchmark</li><li>操作系统：Centos 7.5</li><li>容器镜像：quay.io/coreos/etcd:3.3.10</li></ol></blockquote><p>对应的pod ip列表如下：</p><table><thead><tr><th>机器名</th><th>IP</th></tr></thead><tbody><tr><td>pod 1</td><td>10.245.29.16</td></tr><tr><td>pod 2</td><td>10.245.21.35</td></tr><tr><td>pod 3</td><td>10.245.17.55</td></tr><tr><td>CLIENT</td><td>10.246.12.0/24</td></tr></tbody></table><p>使用这些配置，采样命令如下:</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">HOST_1=http://10.245.29.16:2379  </div><div class="line">HOST_2=http://10.245.21.35:2379  </div><div class="line">HOST_3=http://10.245.17.55:2379</div><div class="line"></div><div class="line"><span class="comment"># 假定 HOST_1 是 leader, 写入请求发到 leader，连接数1，客户端数1</span></div><div class="line">benchmark --endpoints=<span class="variable">${HOST_1}</span> --conns=1 --clients=1 put --key-size=8 --sequential-keys --total=10000 --val-size=256</div><div class="line"></div><div class="line"><span class="comment"># 假定 HOST_1 是 leader, 写入请求发到 leader，连接数100，客户端数1000</span></div><div class="line">benchmark --endpoints=<span class="variable">${HOST_1}</span> --conns=100 --clients=1000 put --key-size=8 --sequential-keys --total=100000 --val-size=256</div><div class="line"></div><div class="line"><span class="comment"># 写入发到所有成员，连接数100，客户端数1000</span></div><div class="line">benchmark --endpoints=<span class="variable">${HOST_1}</span>,<span class="variable">${HOST_2}</span>,<span class="variable">${HOST_3}</span> --conns=100 --clients=1000 put --key-size=8 --sequential-keys --total=100000 --val-size=256</div></pre></td></tr></tbody></table></figure><p>etcd 近似的写入指标如下：</p><table><thead><tr><th>key的数量</th><th>Key的大小</th><th>Value的大小</th><th>连接数量</th><th>客户端数量</th><th>目标 etcd 服务器</th><th>平均写入 QPS</th><th>每请求平均延迟</th><th>内存</th></tr></thead><tbody><tr><td>10,000</td><td>8</td><td>256</td><td>1</td><td>1</td><td>只有主</td><td>126</td><td>7.7ms</td><td></td></tr><tr><td>100,000</td><td>8</td><td>256</td><td>100</td><td>1000</td><td>只有主</td><td>16,033</td><td>60ms</td><td></td></tr><tr><td>100,000</td><td>8</td><td>256</td><td>100</td><td>1000</td><td>所有成员</td><td>15,102</td><td>63ms</td></tr></tbody></table><p><strong>注：key和value的大小单位是 字节 / bytes</strong></p><p>为了一致性，线性化(Linearizable)读取请求要通过集群成员的法定人数来获取最新的数据。串行化(Serializable)读取请求比线性化读取要廉价一些，因为他们是通过任意单台 etcd 服务器来提供服务，而不是成员的法定人数，代价是可能提供过期数据。</p><p>采样命令如下:</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">HOST_1=http://10.245.29.16:2379  </div><div class="line">HOST_2=http://10.245.21.35:2379  </div><div class="line">HOST_3=http://10.245.17.55:2379</div><div class="line"></div><div class="line"><span class="comment"># Linearizable 读取请求</span></div><div class="line">benchmark --endpoints=<span class="variable">${HOST_1}</span>,<span class="variable">${HOST_2}</span>,<span class="variable">${HOST_3}</span> --conns=1 --clients=1 range foo --consistency=l --total=10000</div><div class="line">benchmark --endpoints=<span class="variable">${HOST_1}</span>,<span class="variable">${HOST_2}</span>,<span class="variable">${HOST_3}</span> --conns=100 --clients=1000 range foo --consistency=l --total=100000</div><div class="line"></div><div class="line"><span class="comment"># Serializable 读取请求，使用每个成员然后将数字加起来</span></div><div class="line"><span class="keyword">for</span> endpoint <span class="keyword">in</span> <span class="variable">${HOST_1}</span> <span class="variable">${HOST_2}</span> <span class="variable">${HOST_3}</span>; <span class="keyword">do</span>  </div><div class="line">    benchmark --endpoints=<span class="variable">$endpoint</span> --conns=1 --clients=1 range foo --consistency=s --total=10000</div><div class="line"><span class="keyword">done</span>  </div><div class="line"><span class="keyword">for</span> endpoint <span class="keyword">in</span> <span class="variable">${HOST_1}</span> <span class="variable">${HOST_2}</span> <span class="variable">${HOST_3}</span>; <span class="keyword">do</span>  </div><div class="line">    benchmark --endpoints=<span class="variable">$endpoint</span> --conns=100 --clients=1000 range foo --consistency=s --total=100000</div><div class="line"><span class="keyword">done</span></div></pre></td></tr></tbody></table></figure><p>etcd 近似读取指标如下：</p><table><thead><tr><th>请求数量</th><th>Key 大小</th><th>Value 大小</th><th>连接数量</th><th>客户端数量</th><th>一致性</th><th>每请求平均延迟</th><th>平均读取 QPS</th></tr></thead><tbody><tr><td>10,000</td><td>8</td><td>256</td><td>1</td><td>1</td><td>线性化</td><td>1.2ms</td><td>824</td></tr><tr><td>10,000</td><td>8</td><td>256</td><td>1</td><td>1</td><td>串行化</td><td>0.6ms</td><td>1,628</td></tr><tr><td>100,000</td><td>8</td><td>256</td><td>100</td><td>1000</td><td>线性化</td><td>23.8ms</td><td>37,679</td></tr><tr><td>100,000</td><td>8</td><td>256</td><td>100</td><td>1000</td><td>串行化</td><td>43.5ms</td><td>22,458</td></tr></tbody></table><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>读取指标的时候，按理说串行化要比线性化要好</p><p>影响性能的因素：磁盘（是否SSD），CPU（很多其他应用），内存（这个相对比较充足）</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;理解性能&quot;&gt;&lt;a href=&quot;#理解性能&quot; class=&quot;headerlink&quot; title=&quot;理解性能&quot;&gt;&lt;/a&gt;理解性能&lt;/h2&gt;&lt;p&gt;决定 etcd 性能的关键因素，包括：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;延迟(latency)：延迟是完成操作的时间。&lt;/li&gt;
&lt;li&gt;吞吐量(throughput)：吞吐量是在某个时间期间之内完成操作的总数量。 当 etcd 接收并发客户端请求时，通常平均延迟随着总体吞吐量增加而增加。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Kubernetes" scheme="https://www.flftuu.com/categories/Kubernetes/"/>
    
    
      <category term="etcd" scheme="https://www.flftuu.com/tags/etcd/"/>
    
  </entry>
  
  <entry>
    <title>vim使用方式</title>
    <link href="https://www.flftuu.com/2019/12/26/vim%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
    <id>https://www.flftuu.com/2019/12/26/vim使用方式/</id>
    <published>2019-12-26T03:29:04.000Z</published>
    <updated>2019-12-26T03:37:18.407Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">vim python 语法的检测</div><div class="line">vim 多功能设置</div><div class="line">git 工具的简单 别名配置</div><div class="line">ssh config file 配置</div></pre></td></tr></tbody></table></figure><a id="more"></a><h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mv vim ~/.vim</div><div class="line">mv vimrc ~/.vimrc</div><div class="line">mv gitconfig ~/.gitconfig</div><div class="line">mv ssh ~/.ssh</div></pre></td></tr></tbody></table></figure><p><strong>input < ; + m ></strong><br><img src="/2019/12/26/vim使用方式/m.png" alt="vim_m"></p><p><strong>input < ; + l ></strong><br><img src="/2019/12/26/vim使用方式/l.png" alt="vim_l"></p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;vim&quot;&gt;&lt;a href=&quot;#vim&quot; class=&quot;headerlink&quot; title=&quot;vim&quot;&gt;&lt;/a&gt;vim&lt;/h3&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;vim python 语法的检测&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;vim 多功能设置&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;git 工具的简单 别名配置&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ssh config file 配置&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://www.flftuu.com/categories/Linux/"/>
    
    
      <category term="vim" scheme="https://www.flftuu.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>pod访问svc不通问题</title>
    <link href="https://www.flftuu.com/2019/12/16/pod%E8%AE%BF%E9%97%AEsvc%E4%B8%8D%E9%80%9A%E9%97%AE%E9%A2%98/"/>
    <id>https://www.flftuu.com/2019/12/16/pod访问svc不通问题/</id>
    <published>2019-12-16T07:43:26.000Z</published>
    <updated>2019-12-16T08:45:58.920Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="集群环境"><a href="#集群环境" class="headerlink" title="集群环境"></a>集群环境</h2><p>k8s: v.1.15.3<br>cni: flannel<br>proxy: ipvs</p><a id="more"></a><h2 id="网络访问情景"><a href="#网络访问情景" class="headerlink" title="网络访问情景"></a>网络访问情景</h2><h3 id="pod-访问自身svc"><a href="#pod-访问自身svc" class="headerlink" title="pod 访问自身svc"></a>pod 访问自身svc</h3><p>pod A -> svc -> pod A</p><p>原因: 开启 网桥”hairpinMode” 默认</p><p>解决：cni config文件中配置</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="string">cni-conf.json:</span> <span class="string">|</span></div><div class="line"><span class="string">   {</span></div><div class="line"><span class="string">     "name":"cni0",</span></div><div class="line"><span class="string">     "cniVersion":"0.3.1",</span></div><div class="line"><span class="string">     "plugins":[</span></div><div class="line"><span class="string">       {</span></div><div class="line"><span class="string">         "type":"flannel",</span></div><div class="line"><span class="string">         "delegate":{</span></div><div class="line"><span class="string">           "forceAddress":true,</span></div><div class="line"><span class="string">           "isDefaultGateway":true,</span></div><div class="line"><span class="string">           "hairpinMode":true</span></div><div class="line"><span class="string">         }</span></div><div class="line"><span class="string">       },</span></div><div class="line"><span class="string">       {</span></div></pre></td></tr></tbody></table></figure><h3 id="pod-访问通node节点上pod的svc"><a href="#pod-访问通node节点上pod的svc" class="headerlink" title="pod 访问通node节点上pod的svc"></a>pod 访问通node节点上pod的svc</h3><p>pod A -> svc -> pod B (pod A 和 pod B 在同一node节点上同一cni0 网桥内)</p><p>原因： net.bridge.bridge-nf-call-arptables net.bridge.bridge-nf-call-ip6tables 没开启</p><p>解决：sysctl -w net.bridge.bridge-nf-call-arptables = 1<br>      sysctl -w net.bridge.bridge-nf-call-ip6tables = 1</p><h3 id="pod-访问https的svc-LoadBalancer-类型"><a href="#pod-访问https的svc-LoadBalancer-类型" class="headerlink" title="pod 访问https的svc(LoadBalancer 类型)"></a>pod 访问https的svc(LoadBalancer 类型)</h3><p>pod A(https) -> lb(公网ip) -> pod B</p><p>原因： prxoy 给iptables 添加转发规则，导致集群内部访问svc的公网ip会直接转给相应的pod ip</p><p>解决：把tls证书放在ingress 上。</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;集群环境&quot;&gt;&lt;a href=&quot;#集群环境&quot; class=&quot;headerlink&quot; title=&quot;集群环境&quot;&gt;&lt;/a&gt;集群环境&lt;/h2&gt;&lt;p&gt;k8s: v.1.15.3&lt;br&gt;cni: flannel&lt;br&gt;proxy: ipvs&lt;/p&gt;
    
    </summary>
    
      <category term="Kubernetes" scheme="https://www.flftuu.com/categories/Kubernetes/"/>
    
    
      <category term="flannel" scheme="https://www.flftuu.com/tags/flannel/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 实战-Operator Finalizers 实现</title>
    <link href="https://www.flftuu.com/2019/12/13/Kubernetes-%E5%AE%9E%E6%88%98-Operator-Finalizers-%E5%AE%9E%E7%8E%B0/"/>
    <id>https://www.flftuu.com/2019/12/13/Kubernetes-实战-Operator-Finalizers-实现/</id>
    <published>2019-12-13T09:31:01.000Z</published>
    <updated>2019-12-13T09:49:36.660Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在写 k8s Operator，在看示例的时候看到 controller 都会设置 Finalizers，今天来聊一聊 Finalizers 和相关实现。</p><a id="more"></a><h2 id="Finalizers"><a href="#Finalizers" class="headerlink" title="Finalizers"></a>Finalizers</h2><p>Finalizers 允许 Operator 控制器实现异步的 pre-delete hook。比如你给 API 类型中的每个对象都创建了对应的外部资源，你希望在 k8s 删除对应资源时同时删除关联的外部资源，那么可以通过 Finalizers 来实现。</p><p>Finalizers 是由字符串组成的列表，当 Finalizers 字段存在时，相关资源不允许被强制删除。存在 Finalizers 字段的的资源对象接收的第一个删除请求设置 metadata.deletionTimestamp 字段的值， 但不删除具体资源，在该字段设置后， finalizer 列表中的对象只能被删除，不能做其他操作。</p><p>当 metadata.deletionTimestamp 字段非空时，controller watch 对象并执行对应 finalizers 的动作，当所有动作执行完后，需要清空 finalizers ，之后 k8s 会删除真正想要删除的资源。</p><h2 id="Operator-finalizers-使用"><a href="#Operator-finalizers-使用" class="headerlink" title="Operator finalizers 使用"></a>Operator finalizers 使用</h2><p>介绍了 Finalizers 概念，那么我们来看看在 Operator 中如何使用，在 Operator Controller 中，最重要的逻辑就是 Reconcile 方法，finalizers 也是在 Reconcile 中实现的。要注意的是，设置了 Finalizers 会导致 k8s 的 delete 动作转为设置 metadata.deletionTimestamp 字段，如果你通过 kubectl get 命令看到资源存在这个字段，则表示资源正在删除（deleting）。</p><p>有以下几点需要理解：</p><pre><code>1. 如果资源对象未被删除且未设置 finalizers，则添加 finalizer并更新 k8s 资源对象；2. 如果正在删除资源对象并且 finalizers 仍然存在于 finalizers 列表中，则执行 pre-delete hook并删除 finalizers ，更新资源对象；3. 由于以上两点，需要确保 pre-delete hook是幂等的。</code></pre><h2 id="kuberbuilder-示例"><a href="#kuberbuilder-示例" class="headerlink" title="kuberbuilder 示例"></a>kuberbuilder 示例</h2><p>我们来看一个 kubebuilder 官方示例：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *CronJobReconciler)</span> <span class="title">Reconcile</span><span class="params">(req ctrl.Request)</span> <span class="params">(ctrl.Result, error)</span></span> {</div><div class="line">    ctx := context.Background()</div><div class="line">    log := r.Log.WithValues(<span class="string">"cronjob"</span>, req.NamespacedName)</div><div class="line"></div><div class="line">    <span class="keyword">var</span> cronJob batch.CronJob</div><div class="line">    <span class="keyword">if</span> err := r.Get(ctx, req.NamespacedName, &cronJob); err != <span class="literal">nil</span> {</div><div class="line">        log.Error(err, <span class="string">"unable to fetch CronJob"</span>)</div><div class="line">        <span class="keyword">return</span> ctrl.Result{}, ignoreNotFound(err)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 声明 finalizer 字段，类型为字符串</span></div><div class="line">    myFinalizerName := <span class="string">"storage.finalizers.tutorial.kubebuilder.io"</span></div><div class="line"></div><div class="line">    <span class="comment">// 通过检查 DeletionTimestamp 字段是否为0 判断资源是否被删除</span></div><div class="line">    <span class="keyword">if</span> cronJob.ObjectMeta.DeletionTimestamp.IsZero() {</div><div class="line">        <span class="comment">// 如果为0 ，则资源未被删除，我们需要检测是否存在 finalizer，如果不存在，则添加，并更新到资源对象中</span></div><div class="line">        <span class="keyword">if</span> !containsString(cronJob.ObjectMeta.Finalizers, myFinalizerName) {</div><div class="line">            cronJob.ObjectMeta.Finalizers = <span class="built_in">append</span>(cronJob.ObjectMeta.Finalizers, myFinalizerName)</div><div class="line">            <span class="keyword">if</span> err := r.Update(context.Background(), cronJob); err != <span class="literal">nil</span> {</div><div class="line">                <span class="keyword">return</span> ctrl.Result{}, err</div><div class="line">            }</div><div class="line">        }</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// 如果不为 0 ，则对象处于删除中</span></div><div class="line">        <span class="keyword">if</span> containsString(cronJob.ObjectMeta.Finalizers, myFinalizerName) {</div><div class="line">            <span class="comment">// 如果存在 finalizer 且与上述声明的 finalizer 匹配，那么执行对应 hook 逻辑</span></div><div class="line">            <span class="keyword">if</span> err := r.deleteExternalResources(cronJob); err != <span class="literal">nil</span> {</div><div class="line">                <span class="comment">// 如果删除失败，则直接返回对应 err，controller 会自动执行重试逻辑</span></div><div class="line">                <span class="keyword">return</span> ctrl.Result{}, err</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// 如果对应 hook 执行成功，那么清空 finalizers， k8s 删除对应资源</span></div><div class="line">            cronJob.ObjectMeta.Finalizers = removeString(cronJob.ObjectMeta.Finalizers, myFinalizerName)</div><div class="line">            <span class="keyword">if</span> err := r.Update(context.Background(), cronJob); err != <span class="literal">nil</span> {</div><div class="line">                <span class="keyword">return</span> ctrl.Result{}, err</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">return</span> ctrl.Result{}, err</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reconciler)</span> <span class="title">deleteExternalResources</span><span class="params">(cronJob *batch.CronJob)</span> <span class="title">error</span></span> {</div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// 删除 crobJob关联的外部资源逻辑</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// 需要确保实现是幂等的</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">containsString</span><span class="params">(slice []<span class="keyword">string</span>, s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> {</div><div class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> slice {</div><div class="line">        <span class="keyword">if</span> item == s {</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeString</span><span class="params">(slice []<span class="keyword">string</span>, s <span class="keyword">string</span>)</span> <span class="params">(result []<span class="keyword">string</span>)</span></span> {</div><div class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> slice {</div><div class="line">        <span class="keyword">if</span> item == s {</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        }</div><div class="line">        result = <span class="built_in">append</span>(result, item)</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span></div><div class="line">}</div></pre></td></tr></tbody></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在开发 Operator 时，pre-delete hook 是一个很常见的需求，目前只发现了 Finalizers 适合实现这个功能，需要好好掌握。</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近在写 k8s Operator，在看示例的时候看到 controller 都会设置 Finalizers，今天来聊一聊 Finalizers 和相关实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Kubernetes" scheme="https://www.flftuu.com/categories/Kubernetes/"/>
    
    
      <category term="k8s" scheme="https://www.flftuu.com/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>k8s容器固定ip</title>
    <link href="https://www.flftuu.com/2019/11/06/k8s%E5%AE%B9%E5%99%A8%E5%9B%BA%E5%AE%9Aip/"/>
    <id>https://www.flftuu.com/2019/11/06/k8s容器固定ip/</id>
    <published>2019-11-06T03:03:48.000Z</published>
    <updated>2019-11-06T04:06:43.793Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>kubernetes集群支持容器IP不变（具体来讲，是通过Statefulset创建出来的pod，保持IP不变），<br>固定IP的使用场景是这样的：在开发测试环境中，给开发人员分配一个容器，开发人员通过容器的IP ssh登录进去，进行开发调试。<br>由于这个环境开发人员会长期使用，因此希望容器在发生漂移、重启等变动时，仍然能通过原来的IP登录上去。</p><a id="more"></a><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>IP分配的功能是CNI组件实现的，如flannel作为网络模型，其容器IP分配是和node绑定的（每个node分配的IP都是一个固定网段的）。当容器从一个节点漂移另一个节点后，无法保持原来的IP。</p><p>考虑基于calico网络模型来实现。关于calico的介绍及实现<br>参考：<br>    <span class="exturl" data-url="aHR0cDovL2RvY2tvbmUuaW8vYXJ0aWNsZS8yNTc4" title="http://dockone.io/article/2578">容器网络-从CNI到Calico<i class="fa fa-external-link"></i></span><br>    <span class="exturl" data-url="aHR0cHM6Ly9jaGVueHkuYmxvZy5jc2RuLm5ldC9hcnRpY2xlL2RldGFpbHMvNzUyNzA1Nzg=" title="https://chenxy.blog.csdn.net/article/details/75270578">calico代码解读<i class="fa fa-external-link"></i></span></p><p>calico支持两种类型的ipam，host-local和calico-ipam。host-local的ip分配方式，也是和node节点绑定的。calico-ipam，可以在用户指定的整个容器地址网段内分配IP地址。</p><p>分析calico-ipam的代码，发现其结构清晰，易于改造。<br>实现固定IP的思路如下：<br>    分配IP时，检查当前pod是不是statefulset创建出来的。如果是，检查configmap中有没有保存过pod名字和ip的对应关系，如果有，跳转到指定IP分配逻辑。如果没有，转入calico-ipam的自动IP分配逻辑，并在结束时将pod名字和ip的对应关系，记录到configmap中。</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h2&gt;&lt;p&gt;kubernetes集群支持容器IP不变（具体来讲，是通过Statefulset创建出来的pod，保持IP不变），&lt;br&gt;固定IP的使用场景是这样的：在开发测试环境中，给开发人员分配一个容器，开发人员通过容器的IP ssh登录进去，进行开发调试。&lt;br&gt;由于这个环境开发人员会长期使用，因此希望容器在发生漂移、重启等变动时，仍然能通过原来的IP登录上去。&lt;/p&gt;
    
    </summary>
    
      <category term="Kubernetes" scheme="https://www.flftuu.com/categories/Kubernetes/"/>
    
    
      <category term="docker" scheme="https://www.flftuu.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>k8s集群 iptables vs ipvs性能测试</title>
    <link href="https://www.flftuu.com/2019/11/01/k8s%E9%9B%86%E7%BE%A4-iptables-vs-ipvs%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    <id>https://www.flftuu.com/2019/11/01/k8s集群-iptables-vs-ipvs性能测试/</id>
    <published>2019-11-01T03:17:13.000Z</published>
    <updated>2019-11-06T04:06:35.175Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="对比-iptables-和-ipvs-的性能差异"><a href="#对比-iptables-和-ipvs-的性能差异" class="headerlink" title="对比 iptables 和 ipvs 的性能差异"></a>对比 iptables 和 ipvs 的性能差异</h2><p>测试环境规格：</p><pre><code>master：32C64Gnode: 500个, 规格：2C4G</code></pre><a id="more"></a><h2 id="iptables-vs-ipvs-规则增加延迟"><a href="#iptables-vs-ipvs-规则增加延迟" class="headerlink" title="iptables vs  ipvs 规则增加延迟"></a>iptables vs  ipvs 规则增加延迟</h2><table><thead><tr><th>service 数</th><th>1</th><th>100</th><th>500</th><th>1000</th><th>1500</th><th>2000</th><th>5000</th><th>10000</th><th>15000</th><th>20000</th></tr></thead><tbody><tr><td>rule 数</td><td>4</td><td>400</td><td>2000</td><td>4000</td><td>6000</td><td>8000</td><td>10000</td><td>40000</td><td>60000</td><td>80000</td></tr><tr><td>增加一条 iptables 规则</td><td>77 ms</td><td>100 ms</td><td>491 ms</td><td>1302 ms</td><td>2476 ms</td><td>2662 ms</td><td>6547 ms</td><td>9491 ms</td><td>15125 ms</td><td>20000 ms</td></tr><tr><td>增加一条 ipvs 规则</td><td>0.8 ms</td><td>0.85 ms</td><td>0.85 ms</td><td>0.85 ms</td><td>0.90 ms</td><td>0.90 ms</td><td>0.90 ms</td><td>0.97 ms</td><td>1 ms</td><td>1.52 ms</td></tr></tbody></table><p><img src="/2019/11/01/k8s集群-iptables-vs-ipvs性能测试/1.png" alt="ipvs"></p><p>上图可知：<br>iptables 模式下，随着 服务 规则的增加，增加一条 iptables 规则的时间快速增大。<br>ipvs 模式下，随着 服务 规则的增加，增加一条 ipvs 规则 的时间基本维持在 1 ms 左右。</p><h2 id="iptables-vs-ipvs-服务请求延迟"><a href="#iptables-vs-ipvs-服务请求延迟" class="headerlink" title="iptables vs  ipvs  服务请求延迟"></a>iptables vs  ipvs  服务请求延迟</h2><p>在一定 服务 基数下，对规则链最后的服务 进行 100 并发，1000次请求的 压力测试，得出如下 分布在 iptables 和ipvs 模式下的服务响应延迟。<br><img src="/2019/11/01/k8s集群-iptables-vs-ipvs性能测试/21.png" alt="ipvs"></p><p><img src="/2019/11/01/k8s集群-iptables-vs-ipvs性能测试/2.png" alt="ipvs"></p><p>上图可知：<br>iptables 模式下，随着 服务 规则的增加，服务请求 延迟 增加明显<br>ipvs 模式下，随着 服务 规则的增加，服务请求 延迟 相对平稳维持在 10 ms左右</p><h2 id="iptables-vs-ipvs-cpu-消耗"><a href="#iptables-vs-ipvs-cpu-消耗" class="headerlink" title="iptables vs  ipvs  cpu 消耗"></a>iptables vs  ipvs  cpu 消耗</h2><p><img src="/2019/11/01/k8s集群-iptables-vs-ipvs性能测试/32.png" alt="ipvs"></p><p><img src="/2019/11/01/k8s集群-iptables-vs-ipvs性能测试/3.png" alt="ipvs"></p><p>上图可知：<br>iptables 模式下对 node 节点的资源消耗明显大于  ipvs 模式</p><p>Iptables 存在的问题:</p><blockquote><ol><li>规则顺序匹配延迟大</li><li>访问 service 时需要遍历每条链知道匹配，时间复杂度 O(N)，当规则数增加时，匹配时间也增加。</li><li>规则更新延迟大</li><li>iptables 规则更新不是增量式的，每更新一条规则，都会把全部规则加载刷新一遍。</li><li>规则数大时，会出现 kernel lock</li><li>svc 数增加到 5000 时，会频繁出现 Another app is currently holding the xtables lock. Stopped waiting after 5s， 导致规则更新延迟变大，kube-proxy 定期同步时也会因为 超时导致 CrashLoopBackOff。</li></ol></blockquote></body></html>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;对比-iptables-和-ipvs-的性能差异&quot;&gt;&lt;a href=&quot;#对比-iptables-和-ipvs-的性能差异&quot; class=&quot;headerlink&quot; title=&quot;对比 iptables 和 ipvs 的性能差异&quot;&gt;&lt;/a&gt;对比 iptables 和 ipvs 的性能差异&lt;/h2&gt;&lt;p&gt;测试环境规格：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;master：32C64G
node: 500个, 规格：2C4G
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Kubernetes" scheme="https://www.flftuu.com/categories/Kubernetes/"/>
    
    
  </entry>
  
</feed>
